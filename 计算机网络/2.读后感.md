## 第一章：概述

互联网核心部分：路由器（分组交换）。

电路交换：为每个通信连接指定电路，通话两端始终占用端到端的通信资源。（传输效率低）

分组交换：把数据划分成分离的网络块（报文），通过网络传送。（高效、灵活、迅速、可靠）

## 第二章：物理层

信道：往一个方向传送信息的媒体。

* 单工通信、半双工通信、双工通信

传输媒体可以分为两大类

* 导引型：双绞线、同轴电缆、光缆
  * 重点讲下光缆，由于光的频率非常高(10^8MHZ)，速度=频率×波长，所以光的传输速度非常大；
  * 光缆内，当入射角足够大时，就会出现全反射，光就会沿着光纤不断传输下去；
    * 全反射：当入射角>临界角时，所有的入射光线将被反射而不被折射。
* 非导引型：无线电微波（wifi）

信道复用技术

* 频分复用：用户分到频带后，始终用此频带
* 时分复用：等时划分频带给给用户，但如果用户在时间段内一直不使用，造成浪费，故引出了统计时分复用，添加一个集中器来统计、集中数据。（其前提是用户间断性的工作）
* 波分复用：通过复用器和分用器对不同波长的载波信号进行划分
* 码分复用：通过码片的划分

宽带接入技术：

* ADSL技术：用数字技术对模拟电话用户线进行改造，信号频率分布中：电话频率最低（0-4kHz），而高频给网络使用，其中上行信道频率区间较小（用户上传需求小），下行信道频率较高（下载需求高）。

  其中ADSL调制解调器（猫）成对出行，一个在用户家，一个在电话局中，用户通过电话分离器分离出一条电话线，一条网线。

  **且由于电话分离器是无源的，其将电话信号与数字信号分离开。这样停电时也不影响传统电话的使用。**

  ADSL最大的好处：利用现有电话网的用户线，不需要重新布线。

* HFC网：在有线电视基础上开发的居民宽带接入网

  原来的HFC网的全部频率仅用于电视信号的下行传输（即有线电视只能拉下来看）

  现在具有了双向传输功能，扩展了传输频带（可上可下），即可用于宽带使用。

  在使用ADSL调制解调器中，用户所使用的电话线是用户专用的，因此其最高速率是确定的；但是在HFC电缆中，一个光纤节点（猫将在此，即在此处将光信号转化为电信号）会连接着多个用户，所以一个用户享用的最高数据率是不确定的，若多用户上网，上网速率可能严重影响。

* FTTH（光纤到户），但是其成本有点高。
* FTTx（光纤到楼），到临近用户家庭的地方，才转为铜缆。

## 第三章：数据链路层

数据链路层（传播：帧）使用的信道类型：

* 点对点信道
* 广播信道

点对点信道：

* 链路：结点到相邻结点的物理线路；

  在链路上传输除了物理线路外，还需要必要的通信协议；

  数据链路：链路+实现以上协议的（硬件+软件）

  现在最常用的方法是使用网络适配器（网卡）来实现，一般的适配器都实现了物理层和数据链路层两层功能。

* AB结点通信步骤：

  * A的数据链路层将网络层的IP数据报添加到首部和尾部封装成帧；
  * A把封装好的帧发给B的数据链路层（物理层转为010101二进制流），通过物理层传输媒体传送；
  * B接受到帧后，无差错则提取出IP数据报给网络层，差错则丢弃。

* 数据链路层解决的三个问题：

  * 封装成帧：将数据首尾添加帧定界符，即SOH和EOT，只有在SOH和EOT包含下的帧才是完整的帧

  * 透明传输：如果帧本身出现SOH和EOT这种字符，会出现错误。所以需要对数据进行特殊处理，在SOH和EOT其前面插入一个转义字符ESC，再在接收端接收时将转义字符删除。

  * 差错检测：比特是传输中可能出现0变成1,1变成0，即比特差错。因此，为保证准确率，需要通过循环冗杂检验CRC方法来进行差错检测。

    CRC：在传送的数据（k位）后面添加n位0形成数m，然后事先商量为n+1位数的除数o，最终p=m/o得到余数R，将R叫做冗余码（帧检验序列FCS），用R拼接下m后面形成mR，再将其发送出去。接收端接受到数据后，将帧除以同样的除数o，可以得到余数r，如果传输准确，r一定为0（原理我也母鸡），据此来判断是否出现误码。

    若出现帧丢失、帧重复、帧失序，怎么解决呢？历史上曾经使用过帧编号、确认和重传机制，但由于信道质量现在已得到很大提高，不再使用此方法，而是让上层协议来实现。

* 点对点协议PPP

  * 从用户到ISP之间就是使用PPP协议。

  * PPP帧的首部和尾部分别为4和2个字段。

    头1和尾2都是固定的字段F，即帧定界符。

    头2和头3暂未使用，头4为协议字段，即说明是什么协议，如（LCP（PPP协议的子集：链路控制协议）、IP数据报等）

    尾1是CRC帧检验序列FCS

  * 字节填充

    * 转义方式
    * 零比特填充（即连续7个1插入一个0）

  * PPP协议工作

    * 当用户通过调制解调器呼叫路由器，路由器监测到调制解调器的信号；
    * PPP进行链路建立状态，建立LCP连接，并选择需要的参数
    * NCP给用户分配IP地址
    * 当用户通信完毕后，NCP释放网络连接，收回原来分配的IP地址

广播信道（局域网多使用）

* 共享信道的实现方式

  * 静态划分信道（前面提到的时分复用。。。。）：代价高，不适合局域网使用
  * 动态媒体接入控制
    * 随机接入：所有用户可以同时发送信息，但如果同时发送，会出现碰撞
    * 受控接入：用户不能随机发送，受一定规则控制

* 将局域网的数据链路层拆分为：逻辑链路控制LLC层和媒体接入控制MAC层

* 计算机与外界局域网的连接是通过适配器（网卡）进行，适配器与局域网通过电缆或双绞线串行传输，而适配器与计算机通过IO总线并行传输，适配器的主要功能：进行数据串行传输和并行传输的转换、对数据进行缓存、实现以太网协议。

  **当适配器收到正确的帧时，其通过中断来通知计算机，交付协议上的网络层。计算机发送IP数据报时，协议栈把IP数据报向下交给适配器，组装成帧后发送给局域网。**

* CSMA/CD协议

  CS：多点接入

  MA：载波监听，发送时，每个站必须监听信道，以此获得发送权

  CD：碰撞检测，发送时出现碰撞，立即停止发送

  为什么载波监听了还会出现碰撞？

  为什么电磁波在总线上传输速率有限，可能出现同时发送的情况。

*   CSMA/CD协议要点

  (1)准备发送：适配器从网络获得一个分组，加上首部和尾部组成以太网帧，放入以太网缓存中，发送前先检测信道

  (2)检测信道：若检测到信道忙，则不停检测，直到信道转为空闲；若检测到信道空闲，并在96比特时间内保持空闲，就发送这个帧

  (3)在发送过程中仍不停检测信道，边发送边监听。这里有两种可能：

  发送成功：争用期内未检测到碰撞。这个帧一定能发送成功。发送完毕后回到(1)

  发送失败：争用期内检测到碰撞。立即停止发送，并按规定发送人为干扰信号(强化碰撞)，执行指数退避算法，等待r倍512比特时间后，返回步骤(2)；若重传16次仍不成功，停止重传并向上报错。

* MAC帧格式

   目的地址、源地址。

  类型：用来标志上一层使用的是什么协议

   数据：长度在46~1500字节

   FCS：帧检验序列，使用CRC检验

* 在物理层扩展以太网：集线器

* 在数据链路曾扩展以太网：网桥（通过地址表实现转发过滤的功能）

* 虚拟局域网（VLAN）：是一些局域网网段构成的与物理位置无关的逻辑组

  VLAN标记：在MAC帧的源地址和类型间插入4字节的VLAN标记，交换机收到帧后只向所属VLAN转发，而不进行广播

  最大帧长变为1522字节(1518+4)

## 第四章：网络层

* ![](/media/hpsyche/_dde_data/note/计算机网络/pict/特殊ip地址.png)

  127为网络号的数据报不会发送到任何网络，只是在本地测试，即网络号为127的地址根本不是一个网络地址。

* IP地址特点

  * IP地址管理机构分配IP时只分配网络号，剩下的主机号由该单位自行分配。
  * 路由器根据目的主机所连接的网络号来转发分组，减少路由表的存储空间和查找路由表的时间。
  * 当一台主机连接到两个网络上时，其需要要两个相应的IP地址，其网络号必须是不同的。

* IP数据报首部中的字段

  * 版本：占4位，说明该IP数据报使用的IP协议的版本，通信双方必须使用同一个IP协议版本

  * 首部长度占4位，最大表示数值为15，且其单位是32位字。所以首部长度最大值为15个32位字长，即15*4=60字节。

  * 区分服务：占8位，只在区分服务时才起作用，一般不用

  * 总长度：占16位，说明该IP数据报的总长度(首部+数据)。IP数据报封装为MAC帧时受限于MAC帧的长度上限，所以IP数据报还存在“分片”操作，即将IP数据报分为多片，封装进多个MAC帧。因此IP数据报最大长度2^16-1=65535字节。

    在数据链路层规定了数据帧长度上限MTU，但在IP协议继续规定数据报的最大字节（576字节），但超过此值时，就要进行分片。

  * 标识：占16位，IP数据报若存在分片，则接收方需要将各分片组合出原IP数据报，相同标识号的IP数据报就说明它们其实是同一个源IP数据报。
  * 标志：占3位，目前只有前两位有意义，最低位为MF（More Fragment），若MF=1则说明该数据报后面“还有分片”。中间一位为DF（Don't Fragment），若DF=1则不能分片，只有DF=0才可以分片
  * 片偏移：占13位，用于说明该IP数据报（已分片）在源IP数据报中的相对位置（相对于数据字段的起点），单位是8字节，每个分片一定是8字节的整倍数
  * 生存时间：IP分组在网络中传递时有可能出现“兜圈子”的情况，所以需要对IP数据报进行一定的限制，生存时间的单位是“跳数”，最大值为255，每经过一个路由器，路由器便将IP数据报的生存时间-1，当IP数据报中的生存时间为0时，路由器丢弃该分组。
  * 协议：说明该IP数据报的上层协议类型，如IP对应4，TCP对应6，UDP对应17
  * 首部校验和：验证首部是否存在传输错误，只检验首部，不包括数据部分

* ICMP报文格式

  ![](/media/hpsyche/_dde_data/note/计算机网络/pict/ICMP报文.png)

* ICMP差错报文格式

  ![](/media/hpsyche/_dde_data/note/计算机网络/pict/ICMP差错报文格式.png)

  其中IP数据报的8字节是为了得到运输层的端口号

* ICMP应用举例

  * PING：应用层直接使用网络层ICMP，没有通过运输层的TCP或UDP，由于ICMP报文上都有时间戳，因此很容易得出往返时间。

  * traceroute：路由探测即源主机向目标主机发送无法交付的UDP数据报（封装于IP数据报，若目标主机接收到该数据报，则会返回ICMP终点不可达报文），第一次发送时将IP数据报的生存时间设为1，这样一来第一个路由器接收到后将生存时间-1就会直接判断该IP分组需要丢弃，并返回ICMP时间超过报文，源主机接下来发送第二个IP数据报（依然为不可交付UDP数据报），此次将生存时间设为2……以此类推，直至接收到ICMP终点不可达报文，或生存时间达到上限为止。

    这样子源主机就知道了路由信息——到达目的主机经过的路由器的ip，以及到达其中的每一个路由器的往返时间。

* 自治系统AS

  在单一技术管理下的一组路由器，在AS内部使用内部网关协议，AS之间使用外部网关协议

  内部网光协议IGP：在一个自治系统内部使用。如RIP、OSPF协议

  外部网光协议EGP：在不同自治系统之间使用。如BGP协议

* RIP协议

  概述：是一种分布式，基于距离的路由选择协议

  距离：直连网络距离为1，每过一个非直连网络距离加1，距离也称为跳数，每经过一个路由器跳数就加1，距离实际上指最短距离

  RIP允许一个路径最多包含15个路由器，也就是距离最大值为16，故RIP适合小型互联网使用；RIP不能在两个网络之间同时使用多条路由。                    


  工作流程：每个路由器每隔一段时间向外广播，每个路由器收到广播后更新自己的路由表

  刚开始时只知道直连网络的距离，路由表为空，以后，每个路由器只和数目有限的相邻路由器交互并更新路由信息，经过若干次更新后，所有路由器最终会知道到达本自治系统其他路由器的最短距离和下一跳地址，此时称该网络收敛

  RIP协议的特点：

      (1)仅和相邻路由器交换信息，不相邻的路由器不交换信息
      (2)交换的信息是当前本路由器所知道的全部信息，即其现在的路由表
      (3)按固定时间间隔交换信息
  优点：

  实现简单，开销较小；

  缺点：

  好消息传播快，坏消息传播慢，网络出故障的传播时间需要较长时间；限制了网络的规模

* OSPF协议： 

  主要特征：使用分布式的链路状态协议，而不像RIP使用距离向量协议

  OSPF的特点：

      (1)向本自治系统中所有路由器发送信息。使用洪泛法，向所有相邻路由发送信息，每个相邻路由又再将此信息发给所有相邻路由
      (2)发送信息就是与本路由器相邻的所有路由器的链路状态，说明与哪些路由相邻，以及该链路的"度量"；而不是发生路由表
      (3)只有当链路状态发生变化时，才使用洪泛法发生信息；不是定期更新         
  优点：

  使用泛洪法交换链路信息时，仅在一个区域内而不是整个自治系统中，这减小了整个网络上的通信量。

* EGP

  EGP协议的作用：寻找一条能够到达目的网络且比较好的路由，不一定是最佳路由，采用路径向量路由选择协议。

  各个AS之间有个BGP发言人，用于互相交换网络可达性的信息，然后BGP发言人根据所采用的策略从收到的路由信息中找出到达各AS的较好路由。

* 路由器

  路由器的输入和输出端口都有三层处理模块：物理层、数据链路层、网络层。

  输入端：物理层进行比特的接收；数据链路层则按照链路层协议接收传送分组的帧；在把帧的首部和尾部剥去后，分组就被送入网络层的处理模块。

  输出端同理。

* IPV6

  主要变化：

      更大的地址空间：将地址从32位增大到128位
      扩展的地址层次结构
      灵活的首部格式：定义了很多可选的扩展首部
      改进的选项：允许数据报包含有选项的控制信息，其选项放在有效载荷中
      允许协议继续扩充
      支持即插即用：自动配置，不需要使用DHCP
      支持资源的预分配
      首部改为8字节对齐

* IPV4到IPV6的过渡

  双协议栈：在完全过渡到IPv6前，使一部分主机或路由器装有两个协议栈，使其可与不同网络通信时采用不同的协议，将IPv6数据报报头改为IPv4数据报形式

  隧道技术：在IPv6协议进入IPv4网络时，更改源地址为隧道起点，目的地址变为隧道终点，建立隧道，使整个原IPv6据报作为IPv4数据报的数据部分，在出隧道时改回原来的源地址和目的地址，还原为IPv6数据报

* IP多播

  若视频服务器以单播的形式发送同一个包给90个主机，需要将包复制，发送90个副本，效率低下；

  此时采用多播的形式，数据包只发送一次，路由器在转发分组时，自动将收到的多播包复制成多个副本，转发出去，当分组到达局域网时，由于局域网具有硬件多播的功能，不需要复制分组。

* IGMP(网际组管理协议)

  在多播中，可能有些包不想到达某个路由器，此时就需要用到此协议进行控制。

  IGMP的工作过程：

  当某主机加入新的多播组时，该主机向多播地址发送一个IGMP报文，声明自己成为该组的成员；

  多播路由器周期探寻本地局域网的主机，以便知道这些主机的动态（是否还继续是组的成员）

* 多播路由选择协议

  * 洪泛与剪枝。为了避免多播的兜圈现象，采用反向路径广播PRB技术：当路由器收到包时，判断是否是最短路径发来的，是的话，就向其他所有方向转发收到的包，若不是，则丢弃此包。
  * 隧道技术。封装成单播，进入隧道，再剥去首部，变成多播转发。

* 专用地址

  * 10.0.0.0-10.255.255.255
  * 172.16.0.0-172.31.255.255
  * 192.168.0.0-192.168.255.255

  路由器对于目的地址是专用地址的数据报一律不转发。

* VPN（虚拟专用网）：虚拟出来的企业内部专线。

  在外地工作的员工通过拨号接入网络，而驻留下员工电脑上的VPN软件可以在员工的电脑和公司之间建立VPN隧道，因而员工与公司通信的内容也是保密的，员工们感到好像使用的就是公司的网络。

* 1-你和老婆两地分居，离的很远，现在有种办法能让你们感觉近在咫尺，这种技术就类似VPN！

  2-你和老婆整天住在一起，老吵架，现在又有种技术让你俩物理上离的很近，可实际上好像相距万里，这种技术就类似VLAN！

  VPN主要是把分布在不同地方的网络整合在一起，逻辑上好像都在同一个局域网内；
  VLAN是把一个局域网进一步分割、隔离成更小的网络！

* NAT（网络地址转换）

  使用本地地址的主机在与外界通信时，都要在NAT路由器上将其本地地址转换为全球IP地址，才能和互联网通信。

## 第五章：运输层

* 真正进行通信的实体是在主机中的进程

* 运输层具有——复用、分用的功能。“复用”指的是发送方不同的应用进程都可以使用同一个运输层协议传送数据。“分用”指的是运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程。

* 运输层要对收到的报文进行差错检测。在网络层，IP数据报首部中的检验和字段，只检验首部是否出现差错而不检查数据部分。

* ![](/media/hpsyche/_dde_data/note/计算机网络/pict/不同应用使用的运输层协议.png)

* 为什么使用运输层的端口？

  把特定主机上运行的进程作为互联网上通信的终点不可行，因为进程的创建和撤销是动态的，因此使用协议端口号作为识别的终点，而不需要知道具体进程。

* UDP是面向报文的。对应用程序交下来的报文，添加首部后就交付给IP层。应用程序必须选择合适大小的报文。若报文太长，UDP把它交给IP层后，IP层在传送时可能要进行分片，这会降低IP层的效率；若报文太短，UDP把它交给IP层后，会使IP数据报的首部相对长度太大，这也降低了IP层的效率。

* UDP支持一对一、一对多、多对一和多对多的交互通信。

* UDP首部只有8个字节。

  伪首部：只在计算校验和时使用，不参与数据传输（首部和数据部分一起检验）

  源端口：源端口号；在需要对方回信时选用；不需要时用全0

  目的端口：目的端口号；在终点交付报文时必须使用

  长度：UDP用户数据报的长度，最小值是8(仅有首部)（max：2^1=65535）

  校验和：检测UDP用户数据报在传输过程中是否有错，有就丢弃

* 如果接收方UDP发现收到的报文端口号不正确，则丢弃该报文，并由ICMP发送“端口不可达”差错报文给发送端。（traceroute就是如此，故意发一个非法的UDP端口）

* TCP提供全双工通信。连接的两端都设有发送缓存和接受缓存，用来临时存放双向通信的数据。

* TCP面向字节流。其中的流指的是流入到进程或从进程流出的字节序列。

* TCP并不关心应用进程一次把多长的报文发送到TCP的缓存中，而是根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节。如果应用进程传送到TCP缓存的数据库太长，TCP就可以把它划分成短一些再传送。如果应用进程一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。

* 每一条TCP连接唯一地被通信两端的两个端点（套接字socket）所确定。

  TCP连接::={socket1,socket2} = {(IP1:port1),(IP2:port2)}

* A只要超过一段时间没收到确认，就默认发送的分组丢失而重传之前的分组，就是超时重传

* A发送完一个分组后，必须暂时保留已发送分组的副本，只有在收到相应确认后才删除
  分组和确认都需要编号，才能明确哪个分组收到确认，哪个没收到
  超时计时器的重传时间应比数据在分组传输的平均往返时间更长一些

* TCP虽然是面向字节流的，但是其传送的数据单元也是报文段。

* ![](/media/hpsyche/_dde_data/note/计算机网络/pict/TCP报文.png)

  ```
  (1)源端口和目的端口：各占2字节，分别是源端口号和目的端口号
  (2)序号：占4字节，TCP中传输的数据流中的每一字节都有一个编号。序号字段的值是本报文段所发送的数据的第一个字节的序号
  (3)确认号：占4字节，是期望收到对方下一个报文段的第一个数据字节的序号
  确认号=N，则表明到序号N-1为止所有数据都正确收到
  (4)数据偏移：占4位，指出TCP报文段的数据起始处距离TCP报文段的起始处有多远
  (5)保留：占6位，保留为今后使用
  (6)紧急URG：当URG=1时，表明紧急指针字段有效，告诉系统此报文中有紧急数据，应尽快传送，而不采用原来的按排队顺序来传送
  (7)确认ACK：当ACK=1时确认号字段有效，TCP规定，在连接建立后所有数据报文段都把ACK置为1
  (8)推送PSH：当收到PSH=1的报文时，就尽快交付接收应用进程，而不再等到整个缓存都填满后再向上交付
  (9)复位RST：当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后重新建立连接
  (10)同步SYN：在连接建立时用来同步序号；当SYN=1而ACK=0时，表明这是一个连接请求报文，对方若同一建立连接，则应在响应报文中使SYN=1，ACK=1
  (11)终止FIN：用来释放一个连接，当FIN=1时，表示此报文段的发送方已经发送完毕，并要求释放连接
  (12)窗口：占2字节，指的是发送本段报文段的一方的接收窗口，窗口值作为接收方让对方设置其发送窗口的依据；窗口字段明确指出了现在允许对方发送的数据量，窗口值经常动态变化
  (13)校验和：占2字节，检验和字段检验的范围包括首部和数据两部分
  (14)紧急指针：占2字节，在URG=1时才有意义，指出本报文段中的紧急数据的字节数
  (15)选项：长度可变，最长40字节
  ```

* TCP报文段的数据部分，至少要加上40字节的首部（TCP首部20字节和IP首部20字节）才能组装成一个IP数据报。所以要认真设置MSS（最大报文段长度），太长造成分片，太短网络利用率低下。

* 以字节为单位的滑动窗口

  发送窗口表示：在没有收到B的确认时，A可以连续把窗口内的数据都发送出去

  发送窗口中的序号表示允许发送的序号，窗口越大，发送方就可以在收到对方确认前连续发送更多的数据，因此可能获得更高的传输效率。

  收到新的确认后发送窗口前沿向前移动，没有收到新的确认或收到新的确认但对方通知的窗口缩小了，会使发送窗口前沿不动。

* 如果B收到了32、33的报文，但是没有收到31的报文，此时B也只能对按序收到的最高序号进行确认（即31（期望收到的报文序号）），而不是32和33。这样子的话A不能收到31-33的确认报文，滑动窗口无法前行（不动），如果一直没收到，为了保证可靠传输，A经过一段时间后（由超时计时器控制）重传这部分数据，重新设置超时计时器，直到收到B的确认为止。

* 发送缓存存放：

  发送应用程序发送给发送方TCP准备发送的数据

  TCP已发送出但尚未收到确认的数据

* 接收方缓存存放：

  按序到达的、但尚未被接受应用程序读取的数据

  未按序到达的数据

* 对于未按序到达的报文，先临时存放在接收窗口中，等到字节流所缺少的部分收到后，再按序交付上层的应用进程。

* 超时计时器重传时间多大呢？

  TCP采用自适应算法。记录报文段的往返时间RTT，TCP保留了加权平均往返时间RTTs。

  在计算加权平均RTTs时，只要报文段重传了，就不采用其往返时间样本（重传RTT偏大），这样得出的加权平均RTTs和RTO就较准确。

  但是，如果网络时延突然大了很多，其实重传实践无法更新。进一步改正：报文段每重传一次，超时重传时间RTO增大一些（典型是两倍）。

* 选择确认SACK

   接收方在接受对方发送过来的数据字节流的序号不连续，结构就形成了一些不连续的字节块，如果这些字节的序号都在接受窗口内，接收方就先收下这些数据，但要把这些信息告诉发送方，使发送方不再重复发送这些已收到的数据。

  在建立TCP连接时，需要在TCP首部选项中加“允许SACK”的选项。（大多数的实现还是重传所有未被确认的数据块）。

* TCP报文的发送时机

   第一种机制：TCP维持一个变量，它等于最大报文段长度MSS，当缓存达到MSS时，才组装成一个TCP报文段发送出去

   第二种机制：由发送方的应用进程指明要求发送报文段，即TCP支持的推送操作

   第三种机制：发送方的计时器期限到了，即将已有的缓存数据装入报文段发送出去。

* 拥塞：某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏，这种现象称为拥塞。

* 出现拥塞的原因：对资源的需求>可用资源。

* 拥塞的恶化：如果路由器没有足够缓存空间，就会丢弃一些新到的分组，当分组被丢弃时，发送方就会重传，甚至多次重传，这样会导致更多分组流入网络和被网络中的路由器丢弃。

* 拥塞控制：防止过多的数据注入到网络中，使网络中的路由器或链路不致过载。

* 拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。

* 相反，流量控制往往是点对点通信量的控制，是个端到端的问题（接收端控制发送端）。流量控制所要做的是抑制发送数据的速率，以便使接收端来得及接受（也就是滑动窗口的作用）。

* 举例说明：某个光纤网络链路传输速率是1000Gbit/s，当一台巨型计算机向PC以1Gbit/s的速率传送文件。显然，网络本身的宽带是足够大的，因而不存在拥塞的问题，但是流量控制是必须的，因为巨型计算机必须经常停下来，以便PC来得及接收。

   链路传输速率是1Gbit/s，1000台PC连接网络中，此时是整个网络负载出现问题，需要进行拥塞控制。

* 拥塞控制方法：慢开始、拥塞避免、快重传和快恢复。

* 慢开始：发送方维持一个拥塞窗口cwnd，拥塞窗口的大小取决于网络的拥塞程度，并且在动态的变化，发送方让自己的发送窗口等于拥塞窗口。

   判断拥塞的依据：当网络发生拥塞时，路由器就要丢弃分组。因此只要发送方没有按时收到应到达的确认报文，也就是超时，此时就是猜想网络出现了拥塞。

   慢开始的思路：由小到大逐渐增大拥塞窗口数值

   初始拥塞窗口：初始拥塞窗口设置为1至2个发送方的最大报文段的数值（SMSS）

   算法流程：开始时设置cwnd=1，当收到一个确认报文后，cwnd+1，此时发送两个，收到两个确认报文，cwnd+2，即每经过一次传输轮次，拥塞窗口就加倍。

* RTT：拥塞窗口把允许发送的报文段都发送出去，并收到所有确认报文所经历的时间

* 在TCP实际运行中，发送方只要收到一个对新报文的确认，其cwnd就可以加1，不需要等轮次中所有报文都确认才继续发送。

* 为了防止拥塞窗口增长过大引起网络拥塞，需要设置一个慢开始门限ssthresh状态变量。

   当cwnd<ssthresh，使用上述的慢开始算法

   当cwnd>ssthresh，停止慢开始算法，使用拥避免算法

   当cwnd=ssthresh，慢开始算法，拥避免算法均可以使用

* 拥塞避免：让拥塞窗口缓慢的增大，每经过一个RTT就把发送方的拥塞窗口cwnd+1，而不是像慢开始加倍增长。拥塞窗口按线性规律缓慢增长，比慢开始的拥塞窗口增长速率慢得多。

   拥塞避免不能完全避免拥塞，只是控制拥塞窗口按线性规律增长，使网络不易出现拥塞。

* ![](/media/hpsyche/_dde_data/note/计算机网络/pict/拥塞窗口.jpg)

  当cwnd=24时，网络出现了超时（点2），发送方判断为网络拥塞，于是调整ssthresh=cwnd/2=12，设置cwnd=1，重新进入慢开始阶段；

* 有时，网络包丢失，但不一定是出现拥塞的问题，但如果此时网络误认为是拥塞，就把cwnd设为1，降低了传输效率。

* 快重传：要求接收方不等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。

  假设接收方没有收到M3却收到了M4，此时接收方必须立即发送对M2的重复确认，以便让发送方及时知识接收方没有收到M3，发送方接着发送M5和M6，接收方都需要再次发送对M2的重复确认。按照快重传的规定，一旦发送方收到连续三个重复确认，就知道接收方确实没有M3，立即进行重传（快重传），这样就不会出现超时，发送方也不会误认为出现拥塞。

* 快恢复：发送方只是丢失个别报文，不启动慢开始而用快恢复算法，发送方调整门限值ssthresh=cwnd/2，同时设置拥塞窗口cwnd=ssthresh（开始执行拥塞避免算法）。

* 发送方窗口的上限值：发送方的发送窗口一定不能超过对方给出的接收方窗口值rwnd；

  上限值应取接收方窗口和拥塞窗口这两个变量中较小的一个，即发送方窗口的上限值= min(rwnd,cwnd)

  当rwnd < cwnd 时，是接收方的接收能力限制发送方窗口的最大值。

  当cwnd < rwnd 时，则是网络的拥塞限制发送方窗口的最大值。

* 主动队列管理AQM

  路由器的队列通常都是按照“先进先出”FIFO (First In First Out) 的规则处理到来的分组。

  当队列已满时，以后再到达的所有分组（如果能够继续排队，这些分组都将排在队列的尾部）将都被丢y弃。这就叫做尾部丢弃策略 (tail-drop policy)。

  路由器的尾部丢弃往往会导致一连串分组的丢失， 这就使发送方出现超时重传，使TCP进入拥塞控制的慢开始状态，结果使TCP连接的发送方突然把数据的发送速率降低到很小的数值。

  更为严重的是，在网络中通常有很多的TCP连接， 这些连接中的报文段通常是复用在网络层的IP数据报中传送的。这种情况下，若发生了路由器中的尾部丢弃，就可能会同时影响到很多条TCP连接，结果使这许多TCP连接在同一时间突然都进入到慢开始状态。这在TCP 的术语中称为**全局同步** (global syncronization)。

  全局同步使得全网的通信量突然下降了很多，而在网络恢复正常后，其通信量又突然增大很多。

  因此提出了主动队列管理：所谓“主动”就是不要等到路由器的队列长度已经达到最大值时才不得不丢弃后面到达的分组。这样就太被动了。应当在队列长度达到某个值得警惕的 数值时（即当网络拥塞有了某些拥塞征兆时），就主动丢弃到达的分组。提醒发送方放慢发送速率， 会有可能减轻网络拥塞甚至不出现拥塞。

* 三次握手

  ![](/media/hpsyche/_dde_data/note/计算机网络/pict/三次握手.png)

  最初两端TCP进程都处于关闭状态，开始时B的TCP服务器进程先创建传输控制块TCB，准备接受客户进程的连接请求，然后进入收听状态；

  * TCB：每一个连接中的重要信息，如：TCP连接表、指向发送和接受缓存的指针、指针重传队列的指针、当前的发送和接受序号

  A的TCP客户进程也先创建TCB，然后打算建立TCP连接时，向B发送连接请求报文，这是首部中同步位SYN=1，同时选择一个初始序号seq=x，TCP规定，**SYN报文段不能携带数据，但要消耗一个序号**，这时TCP客户进程进入同步已发送状态；

  B收到连接请求报文后，若同意建立连接，则向A发送确认。在确认报文中将SYN位和ACK位都置1，确认号时ACK=x+1，同时也为自己选择一个初始序号seq=y。**这个报文段也不能携带数据，但同样消耗一个序号**，这时TCP服务器进程进入同步收到状态。

  TCP客户进程收到B的确认后，还要向B给出确认。确认报文的ACK置1，确认号ack=y+1，而自己的序号seq=x+1。TCP规定，**ACK报文段可以携带数据，但如果不携带数据则不消耗序号**，这种情况，下一个数据报文段序号仍是seq=x+1。这时TCP连接已经建立，A进入已建立连接状态。

  为什么A最后还要发送一次确认呢？

  * 1.让B确认A的接受能力

  * 2.三次握手主要是为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。“已失效的连接请求报文段”是这样产生的：

    a.考虑一种正常情况。

    A发出连接请求，但因连接请求报文丢失而未收到确认。于是A再重传一次连接请求。后来收到了确认，建立的连接。数据传输完毕后，就释放了连接。A共发送了两个连接请求报文段，其中第一个丢失，第二个到达了B。没有“已失效的连接请求报文段”。

    b.假定现出现了一种异常情况。

    A发出的第一个连接请求报文段没有丢失，而是在某些网络节点长时间滞留了，以致厌恶到连接释放以后的某个时间才到达B.但B受到此失效的连接请求报文段后，就误认为是A又发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。但其实A并没有发出新的连接请求，因此不回理睬B的确认，也不会像B发送数据。而B却以为新的运输链接已经建立了，并一直等待A发来数据。B的许多资源就这样白白浪费了。

    因此，采用三次握手的办法可以防止上述现象的发生。例如在刚才的情况下，A不会向B的确认发出确认。B由于收不到确认，就知道A并没有要求连接。

* 四次挥手

  ![](/media/hpsyche/_dde_data/note/计算机网络/pict/四次挥手.png)

  起始时A和B都处于已建立连接状态

  A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接，A把连接释放报文段首部的终止控制位FIN置1，序号seq=u，它等于前面已传送过的数据的最后一个字节的序号+1。这时A进入终止等待状态。**FIN报文段即使不携带数据，也消耗一个序号**。

  B收到连接释放报文后发出确认，确认号是ack=u+1，而这个报文自己的序号是v，等于B前面已传送过的数据的最后一个字节的序号+1。然后B进入关闭等待状态，TCP服务器进程通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于半关闭状态，即A已经没有数据要发送了，但B若发送数据，A仍要接受。

  A收到来自B的确认后，进入终止等待2状态，等待B发送的连接释放报文段。

  若B已经没有要向A发送的数据，应用进程就通知TCP释放连接，此时B发出的连接释放报文段FIN=1，假定现在B的序号为w，B还必须重复上次已发送过的确认号ack=u+1，此时B进入最后确认状态，等待A的确认。

  A在收到B的链接释放报文后，必须对此发出确认，在确认报文段中把ACK置1，确认号ack=w+1，而自己的序号时seq=u+1，然后进入时间等待状态。此时TCP连接还没有释放，必须经过时间等待计时器设置的时间2MSL后，A才进入关闭状态。

  * 为什么要等到2MSL？

    2MSL（MSL为最长报文段寿命，由时间等待计时器控制）

    第一，为了保证A发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因为使处在LAST-ACK状态的B收不到对已发送的FIN + ACK报文段的确认。B会超时重传这个FIN + ACK报文段，而A就能在2MSL时间内收到这个重传的FIN + ACK报文段。接着A重传一次确认，重新启动2MSL计时器。最后，A和B都正常进入到CLOSED状态。如果A在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后立即释放连接，那么就无法收到B重传的FIN + ACK报文段，因为也不会再发送一次确认报文段。这样，B就无法按照正常步骤进入CLOSED状态。

    第二，防止“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

  * 主要到，B结束TCP连接的时间要比A快一些。

  * TCP除了时间等待计时器外，还拥有保活计时器，设想：当客户已主动与服务器建立了TCP连接，但后来客户端的主机突然出故障。显然，服务器以后就不能再收到客户发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就是保活计时器。

    服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置**通常是两个小时。若两个小时没有收到客户的数据，服务器就发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文段后仍无客户的相应，服务器就认为客户端出了故障，接着就关闭这个连接。**

    