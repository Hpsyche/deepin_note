## 面向对象编程

### 契约接口

#### Aware

Spring中有很多继承至`aware`接口的类或接口：

![](/media/hpsyche/_dde_data/note/spring/pict/1-1.png)

作用为何呢？

`aware`,翻译过来是知道的，已感知的，意识到的，所以这些接口从字面意思应该是能感知到所有`Aware`前面的含义。

先举个`BeanNameAware`的例子，实现`BeanNameAware`接口，可以让该`Bean`感知到自身的`BeanName`（对应Spring容器的`BeanId`属性）属性,举个例子：https://www.jianshu.com/p/c5c61c31080b

我们在实现了`BeanNameAware`的 `User`中，获取到了Spring容器中的`BeanId`（对应`spring配置文件`中的`id`属性），而没有实现`BeanNameAware`的`User2`，则不能获取到Spring容器中的Id属性。

**所以`BeanNameAware`接口是为了让自身`Bean`能够感知到，获取到自身在Spring容器中的id属性。**

**同理，其他的`Aware`接口也是为了能够感知到自身的一些属性。**

比如实现了`ApplicationContextAware`接口的类，能够获取到`ApplicationContext`，实现了`BeanFactoryAware`接口的类，能够获取到`BeanFactory`对象。

### BeanPostProcessor

 Bean对象后置处理

### 设计模式

观察者模式：ApplicationEvent

组合模式

模板模式：JdbcTemplate

。。。。

### 对象继承

Abstract***类

## 面向切面编程

### 动态代理

JdkDymaicAopProxy

### 字节码提升

ASM

CGLib

AspectJ

## 面向元编程

### 注解

模式注解

* @Component
* @Repository
* @Service
* @Controller

### 配置

Environment抽象

PropertySources

BeanDefinition

### 泛型

GenericTypeResolver

ResolvableType

## 函数驱动

### 函数接口

ApplicationEventPublisher

### Reactive

Spring WebFlux

## 模块驱动

Maven Artifacts

OSGI Bundles

Java 9 Automatic Modules

Spring @Enable*