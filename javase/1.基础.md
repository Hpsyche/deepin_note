* jdk1.8中接口通过default关键字可以设置默认实现方法。

  便于扩展接口中的方法而不破坏原有的集成体系。

* ArrayList类为什么还要实现List接口，它不已经实现了AbstractList这个抽象类了吗？ 这个抽象类都已经有了接口里的方法，在去实现不是多此一举吗？

  首先接口意义在于规范设计，但接口是没有具体实现的（1.8版本之后的静态方法除外），所有继承它的类都需要一个个实现它的所有方法。
  但是呢接口可能有些方法具有一定的通用性，也就是说不需要所有实现类都单独实现（实现了代码也是重复的），有一个类实现这几个方法，大家都去继承它好了，剩下的接口大家各自实现，这就是模板类的意义。

  现在关键问题来了，为什么要把这个模板类定义成抽象类呢？其实上面已经给出了答案，因为继承接口的实现类必须要实现接口的所有方法，而模板类仅仅是为了实现一些通用方法不需要实现所有接口方法（总不能为了提供这个模板，稀里糊涂的把所有接口方法都实现了吧，没有必要不说，还和可能产生不必要的使用。），这时候抽象类就符合这个需求了。
  抽象类实现了通用的接口，剩下的接口谁继承我谁实现，而且抽象类本身又不能实例化，不会产生没有实现的接口滥用。既实现了代码的最大化复用，又实现了代码的最大化精简。类似 高内聚，低耦合？

  **由于抽象类并未对接口中的所有方法都进行实现，而只是对接口中的部分方法进行了实现（为了达到多态解耦的目的），还须由子类重新对接口中剩余的抽象方法进行一次实现来完善。所以再给子类声明了一次这个接口，用来对此作个标记。子类写不写上都是可以的，更多的是体现了一种规范。**
  
* 1静态内部类里面是如何访问外部类的变量？

  通过JAVAC也就是编译阶段产生一个访问外部类的一个static的access访问方法，然后在静态内部类中通过外部类的类名.access方法访问。

* 2非静态内部类里面是如何访问外部类的变量？

  在构造内部类时，默认new出一个外部类的对象，然后在调用内部类时通过构造器传入外部类，这样就可以在内部类中，通过对外部类的对象来访问外部类的成员变量。

* 3对于内部类访问外部类的属性

  无论外部类中是静态变量还是实例变量：外部类生成一个access$x00的方法来给内部类调用（以此访问外部类的变量）；

  不同点在于，访问实例变量时需要通过第2点获得的外部类的对象来进行访问。

* 4匿名内部类和普通内部类访问外部类的属性是一样的，都是将外部类的对象传入到内部类，而且对于外部类所创建的对象，（外部类）都会自动生成一个access访问方法供内部类进行访问。

* 泛型这种东西，是为了避免ClassCastException，引入通配符是因为泛型没有继承关系，而通配符规定上下限是为了避免破坏泛型机制。

* 



