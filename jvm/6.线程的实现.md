## 线程简介

线程是比进程更轻量级的调度单位，各个线程既可以共享进程资源，又可以独立调度，更充分地利用计算机的资源。

## 实现线程的方式

### 使用内核线程实现

内核线程（Kernel-Level Thread，KLT）：操作系统内核直接支持的线程，由内核来完成线程切换。（比较重量级）

程序一般不会直接去使用内核线程，而是通过内核线程的一种高级接口——轻量级进程（Light Weight Process，LWP），每个轻量级进程都由一个内核线程支持。

这种轻量级进程和内核线程之间的1:1关系称为一对一的线程模型，如下图所示：

![](/media/hpsyche/_dde_data/note/jvm/pict/线程之1:1.JPG)

优点： 由于内核线程的支持，每个轻量级进程都有一个独立的调度单元，即使轻量级进程在系统中阻塞了，也不会影响整个进程继续工作；

​	缺点：基于内核线程实现，各种线程操作的代价较高，需要在用户态和内核态中来回切换；每个轻量级进程都需要一个内核线程的支持，需要消耗一定的内核资源。

### 使用用户线程实现

用户线程：完成建立在用户空间的线程库上，系统内核不能感知用户线程存在。

这种进程与用户线程之前1：N的关系称为一对多的线程模型。

如下图所示：

![](/media/hpsyche/_dde_data/note/jvm/pict/线程之1:N.JPG)

优点：用户线程的建立、调度等操作完成在用户态中完成，不需要内核的帮助。如果程序实现得当，线程不需要切换到内核态，因此操作会快速且低消耗。

缺点：由于没有系统内核的支持，所有的线程操作需要用户程序自己处理；且由于操作系统只把处理器资源分配到进程，诸如“多处理系统中如何将线程映射到其他处理器上”等问题解决起来十分困难；由于线程对操作系统透明，调度处于进程级别，若进程中的一个线程通过系统调用进入操作系统受阻，那么将阻塞该进程。

### 使用用户线程加轻量级进程混合实现

### 使用用户线程加轻量级进程混合实现

N：M的关系。

![](/media/hpsyche/_dde_data/note/jvm/pict/线程之N:M.JPG)

### Java线程的实现

对于Sun JDK来说，其Windows版与Linux版都是使用一对一的线程模型实现的，一个Java线程映射到一条轻量级进程中，因为Windows与Linux提供的线程模型就是一对一的。

#### Java线程的状态转换

Java线程的状态有如下：

* 新建（New）：创建后未启动的线程处于这种状态；

* 运行（Runnable）：包括了Running和Ready，即处于此状态的线程有可能正在运行，也可能正在等待CPU为它分配执行时间；线程获取CPU后进入Running状态；而时间片走完，或者调用yield，则进入Ready状态

  * 注意：I/O阻塞时，线程是处于Runnable状态的，下文会解释。

* 无限期等待（Waiting）：不被分配CPU执行时间，需要等到其他线程显式地唤醒。

  以下方法会让线程进入此状态：

  * 没有设置Timeout的Object.wait()方法
  * 没有设置Timeout的Thread.join()方法
  * LockSupport.park()方法

* 限期等待（Timed Waiting）：处于此状态的线程不会被CPU分配执行时间，但是在一定时间后其会由系统自动唤醒。

  以下方法会让线程进入此状态：

  * Thread.sleep()
  * 设置了Timeout的Object.wait()方法
  * 设置了Timeout的Thread.join()方法
  * LockSupport.parkNanos()方法
  * LockSupport.parkUntil()方法

* 阻塞（Blocked）：线程在等待着获取一个排它锁；在程序等待进入同步区域时，线程进入此状态；

* 结束（Terminated）：已终止线程的线程状态。

注意：

从以上可以看出sleep和wait的区别，如下：

* sleep为Thread的方法，而wait为Object的方法；
* 都会让出CPU资源（只有running状态占用cpu资源），但是sleep不会释放锁资源，wait会释放锁资源；

#### 疑问

以下内容《转自https://www.cnblogs.com/goodAndyxublog/p/11613770.html》

使用 Java 阻塞 I/O 模型读取数据，将会导致线程阻塞，线程将会进入休眠，从而让出 CPU 的执行权，直到数据读取完成。这个期间如果使用 jstack 查看线程状态，却可以发现Java 线程状态是处于 RUNNABLE，这就和上面说的存在矛盾，为什么会这样？

首先引入操作系统的线程状态，如下图所示：

![](/media/hpsyche/_dde_data/note/jvm/pict/操作系统线程状态.png)

这 5 中状态详细情况如下：

1. 初始状态，这时候线程刚被创建，还不能分配 CPU 。
2. 可运行状态，线程等待系统分配 CPU ，从而执行任务。
3. 运行状态，操作系统将 CPU 分配给线程，线程执行任务。
4. 休眠状态，运行状态下的线程如果调用阻塞 API，如阻塞方式读取文件， 线程状态就将变成休眠状态。这种情况下，线程将会让出 CPU 使用权。休眠结束，线程状态将会先变成可运行状态。
5. 线程执行结束或者执行过程发生异常将会使线程进入终止状态，这个状态下线程使命已经结束。

上面的矛盾其实是混淆了操作系统线程状态与 Java 线程状态。**这里说的线程阻塞进入休眠状态，其实是操作系统层面线程实际状态。而我们使用 jstack 查看的线程状态却是 JVM 中的线程状态。**

比较 Java 线程与操作系统线程，可以发现 Java 线程状态没有可运行状态。也就是说 Java 线程 RUNNABLE 状态包括了操作系统的可运行状态与运行状态。一个处于  RUNNABLE 状态 Java 线程，在操作系统层面状态可能为可运行状态，正在等待系统分配 CPU 使用权。

另外 Java 线程细分了操作系统休眠状态，分成了 BLOCKED，WATTING，TIMED_WAITING 三种。

当线程调用阻塞式 API，线程进入休眠状态，这里指的是操作系统层面的。从 JVM 层面，Java 线程状态依然处于 RUNNABLE 状态。JVM 并不关心操作系统线程实际状态。从 JVM 看来等待 CPU 使用权（操作系统线程状态为可运行状态）与等待 I/O （操作系统线程状态处于休眠状态）没有区别，都是在等待某种资源，所以都归入 RUNNABLE 状态。

