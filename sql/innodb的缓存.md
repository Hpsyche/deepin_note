![](/media/hpsyche/_dde_data/note/sql/pict/Innodb的缓存和日志.png)

![](/media/hpsyche/_dde_data/note/sql/pict/flush操作.png)

![](/media/hpsyche/_dde_data/note/sql/pict/flush操作2.png)

什么时候将内存中的日志缓冲写到磁盘上的日志文件呢?

可以修改innodb_flush_log_at_trx_commit变量来控制刷新的频率（默认为1）：

* 0：每秒钟刷新一次，但是事务提交时不做任何事
* 1：每次事务提交都刷新到持久化存储（即确保写到磁盘上）。这是一个阻塞IO的调用，知道数据被完全写回才完成。因为写数据到磁盘比较慢，所以此情况可以明显降低innodb每秒提交的事务数。但是这也是最安全的设置。
* 2：每秒刷新一次，事务提交时写到日志文件中。与0最大的区别是，如果Mysql进程挂了，2不会丢失任务事务，最多导致1s数据丢失。

高性能事务处理需要的最佳配置为，参数为1，并且把日志文件放到一个有电池保护的写缓存的RAID卷中。

* RAID：独立磁盘冗余阵列，具有两大特点：一是速度、二是安全。

那么什么时候会进行flush操作呢？

* InnoDB的redo log写满了。这时候系统会停止所有更新操作，把checkpoint往前推进，redo log留出空间可以继续写。
* 系统内存不足。当需要新的内存页，而内存不够用的时候，就要淘汰一些数据页，空出内存给别的数据页使用。如果淘汰的是“脏页”，就要先将脏页写到磁盘。
* MySQL认为系统“空闲”的时候，见缝插针地找时间，只要有机会就刷一点“脏页”。
* MySQL正常关闭的情况。这时候，MySQL会把内存的脏页都flush到磁盘上，这样下次MySQL启动的时候，就可以直接从磁盘上读数据，启动速度会很快。

在以上写线程到表空间中，其实还有个双写缓冲（Doublewrite Bufffer）。

* 其用来避免页没写完整所导致的数据损坏。当Innodb从缓冲池刷新页面到磁盘时，首先把它们写到双写缓冲，然后再把它们写到其所属的数据区域中，以此保证每个页面的写入都是原子且持久化的。

* 这意味着每个页都要写两遍。但是因为Innodb写页面到双写缓冲是顺序的，并且只调用一次fsync()刷新到磁盘，所以实际上对性能的冲击是比较小的。

* 如果有一个不完整的页写到了双写缓冲，原始的页依然会在磁盘上其真实位置。Innodb恢复时，将原始页面替换掉双写缓冲中损坏的页面。如果双写缓冲成功写入，但写到页真实位置失败了，Innodb在恢复时，将双写缓冲中的拷贝替换。

* Innodb如何知道页面损坏呢？

  每个页面在末尾都有校验值。因此，在恢复的时候，Innodb只需要读取双写缓冲中的每个页面并且验证校验值。如果一个页面的校验值不对，就从它的原始位置读取这个页面。

* 默认情况在，双写缓冲是打开的，也可以通过设置innodb_doublewrite为0来关闭双写缓冲。

