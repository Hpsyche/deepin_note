## 只运行一次

```go
type Singleton struct {
}

var singleInstance *Singleton
var once sync.Once

func GetSingletonObj() *Singleton {
	once.Do(func() {
		fmt.Println("Create Obj")
		singleInstance = new(Singleton)
	})
	return singleInstance
}

func TestGetSingletionObj(t *testing.T) {
	var wg sync.WaitGroup
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func() {
			obj := GetSingletonObj()
			fmt.Printf("%p\n", obj)
			wg.Done()
		}()
	}
	wg.Wait()
}
//output:
Create Obj
0x6622e8
0x6622e8
0x6622e8
0x6622e8
0x6622e8
0x6622e8
0x6622e8
0x6622e8
0x6622e8
0x6622e8
```

## 所需任意任务完成

```go
func runTask(i int) string {
	a := rand.Intn(100)
	time.Sleep(time.Duration(a) * time.Millisecond)
	return fmt.Sprintf("the result is %d", i)
}

func FirstResponse() string {
	num := 10
	ch := make(chan string)
	for i := 0; i < num; i++ {
		go func(i int) {
			ret := runTask(i)
			ch <- ret
		}(i)
	}
	return <-ch
}

func TestFirstResponse(t *testing.T) {
	fmt.Println("Before Num:", runtime.NumGoroutine())
	fmt.Println(FirstResponse())
	fmt.Println("After Num:", runtime.NumGoroutine())
}
//output:
Before Num: 2
the result is 0
After Num: 11
```

发现，某条协程收到channel后数据后，该协程退出，但其他协程依旧没有退出，造成了内存泄露。

修改方案：

```go
func runTask(i int) string {
	a := rand.Intn(100)
	time.Sleep(time.Duration(a) * time.Millisecond)
	return fmt.Sprintf("the result is %d", i)
}

func FirstResponse() string {
	num := 10
	ch := make(chan string,num)
	for i := 0; i < num; i++ {
		go func(i int) {
			ret := runTask(i)
			ch <- ret
		}(i)
	}
	return <-ch
}

func TestFirstResponse(t *testing.T) {
	fmt.Println("Before Num:", runtime.NumGoroutine())
	fmt.Println(FirstResponse())
	fmt.Println("After Num:", runtime.NumGoroutine())
}
//output:
Before Num: 2
the result is 0
After Num: 2
```

通过buffer机制，只要buffer有足够的空间，生产者往buffer放置数据即可退出。	

## 所有任务完成

```django
func AllResponse() string {
	num := 10
	ch := make(chan string)
	for i := 0; i < num; i++ {
		go func(i int) {
			ret := runTask(i)
			ch <- ret
		}(i)
	}
	res := ""
	for j := 0; j < num; j++ {
		res += <-ch + "\n"
	}
	return res
}

func TestFirstResponse(t *testing.T) {
	fmt.Println("Before Num:", runtime.NumGoroutine())
	fmt.Println(AllResponse())
	time.Sleep(1 * time.Second)
	fmt.Println("After Num:", runtime.NumGoroutine())
}
//output:
Before Num: 2
the result is 3
the result is 8
the result is 0
the result is 2
the result is 1
the result is 4
the result is 9
the result is 6
the result is 5
the result is 7
After Num: 2
```

注意：以上的字符串拼接并不高效，这是只是演示。

## 对象池

使用buffered channel实现对象池。

```go
package my_objpool

import (
	"errors"
	"time"
)

type ResuableObj struct {
}

type ObjectPool struct {
	bufChan chan *ResuableObj
}

func NewObjPool(numObj int) *ObjectPool {
	objPool := ObjectPool{}
	objPool.bufChan = make(chan *ResuableObj, numObj)
	for i := 0; i < numObj; i++ {
		objPool.bufChan <- &ResuableObj{}
	}
	return &objPool
}

func (p *ObjectPool) GetObj(timeout time.Duration) (*ResuableObj, error) {
	select {
	case ret := <-p.bufChan:
		return ret, nil
	case <-time.After(timeout):
		return nil, errors.New("time out")
	}
}

func (p *ObjectPool) ReleaseObj(obj *ResuableObj) error {
	select {
	case p.bufChan <- obj:
		return nil
	default:
		return errors.New("overflow")
	}
}
```

测试1：

```go
func TestObjectPool(t *testing.T) {
	pool := NewObjPool(10)
	for i := 0; i < 11; i++ {
		if v, err := pool.GetObj(time.Second * 1); err != nil {
			t.Error(err)
		} else {
			fmt.Printf("%T\n", v)
			if err := pool.ReleaseObj(v); err != nil {
				t.Error(err)
			}
		}
	}
}
//output:
*my_objpool.ResuableObj
*my_objpool.ResuableObj
*my_objpool.ResuableObj
*my_objpool.ResuableObj
*my_objpool.ResuableObj
*my_objpool.ResuableObj
*my_objpool.ResuableObj
*my_objpool.ResuableObj
*my_objpool.ResuableObj
*my_objpool.ResuableObj
*my_objpool.ResuableObj
```

可见，对象池得以实现，用完即释放；

当我们不释放时呢？

```go
func TestObjectPool(t *testing.T) {
	pool := NewObjPool(10)
	for i := 0; i < 11; i++ {
		if v, err := pool.GetObj(time.Second * 1); err != nil {
			t.Error(err)
		} else {
			fmt.Printf("%T\n", v)
			// if err := pool.ReleaseObj(v); err != nil {
			// 	t.Error(err)
			// }
		}
	}
}
//output:
*my_objpool.ResuableObj
*my_objpool.ResuableObj
*my_objpool.ResuableObj
*my_objpool.ResuableObj
*my_objpool.ResuableObj
*my_objpool.ResuableObj
*my_objpool.ResuableObj
*my_objpool.ResuableObj
*my_objpool.ResuableObj
*my_objpool.ResuableObj
    /home/hpsyche/goProjects/go_learning/src/main/ch15/my_objpool/TestObjectPool: objpool_test.go:13: time out
--- FAIL: TestObjectPool (1.00s)
```

在设置第11个变量时，报错。

当对象池没有对象时，调用ReleaseObj：

```go
func TestObjectPool(t *testing.T) {
	pool := NewObjPool(10)
	if err := pool.ReleaseObj(&ResuableObj{}); err != nil {
		t.Error(err)
	}
}

//output:
    /home/hpsyche/goProjects/go_learning/src/main/ch15/my_objpool/TestObjectPool: objpool_test.go:12: overflow
```

## Sync.pool对象缓存

![](/media/hpsyche/_dde_data/note/go/go基础/pict/5-1.jpg)

### sync.Pool对象获取

* 尝试从私有对象获得
* 私有对象不存在，尝试从当前Processor的共享池获取
* 如果当前Processor共享池也是空的，那么就尝试去其他Processor的共享池获取
* 如果所有子池都是空的，最后就用用户指定的New函数产生一个新的对象返回

### sync.Pool对象的放回

* 如果私有对象不存在则保存为私有对象
* 如果私有对象存在，放入当前Processor子池的共享池中

### sync.Pool对象的生命周期

* GC会清除sync.pool缓存的对象
* 对象的缓存有效期为下一次GC之前

### 使用sync.Pool

```go
pool:=&sync.Pool{
    New:func() interface{}{
        return 0
    },
}
array:=pool.Get().(int)
...
pool.Put(10)
```

### 举例

```go
func TestSyncPool(t *testing.T) {
	pool := &sync.Pool{
		New: func() interface{} {
			fmt.Println("Create a new Object.")
			return 100
		},
	}
	v := pool.Get().(int)
	fmt.Println(v)
	pool.Put(3)
	v1, _ := pool.Get().(int)
	fmt.Println(v1)
}
//output:
Create a new Object.
100
3
```

```go
func TestSyncPool(t *testing.T) {
	pool := &sync.Pool{
		New: func() interface{} {
			fmt.Println("Create a new Object.")
			return 100
		},
	}
	v := pool.Get().(int)
	fmt.Println(v)
	pool.Put(3)
	runtime.GC()
	v1, _ := pool.Get().(int)
	fmt.Println(v1)
}
//output:
Create a new Object.
100
Create a new Object.
100
```

可以看到，当GC后，对象缓存不再存在，重新创建缓存。

```go
func TestSyncPoolInMultiGrountine(t *testing.T) {
	pool := &sync.Pool{
		New: func() interface{} {
			fmt.Println("Create a new Object.")
			return 100
		},
	}
	pool.Put(1)
	pool.Put(2)
	pool.Put(3)
	var wg sync.WaitGroup
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func() {
			fmt.Println(pool.Get())
			wg.Done()
		}()
	}
	wg.Wait()
}
//output:
1
Create a new Object.
100
Create a new Object.
100
Create a new Object.
100
Create a new Object.
100
Create a new Object.
100
Create a new Object.
100
2
3
Create a new Object.
100
```

可以看到，再对象缓存中数据被取出后，再取将会重新创建对象（一次性，不会放入缓存，若想放入需要手动Put）。

### sync.Pool总结

* 适用于通过复用，降低复杂对象的创建和GC代价
* 协程安全，会有锁的开销
* 生命周期受GC影响，不适合于做连接池等，需自己管理生命周期的资源的池化

