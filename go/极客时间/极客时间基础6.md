## 单元测试

一般测试文件在同一个包中，后缀加上_test。

如有方法文件functions.go如下：

```go
package testing

func square(op int) int {
	return op * op
}
```

我们可以定义如下测试文件functions_test.go：

```go
package testing

import "testing"

func TestSquare(t *testing.T) {
	inputs := [...]int{1, 2, 3}
	expected := [...]int{1, 4, 9}
	for i := 0; i < len(inputs); i++ {
		ret := square(inputs[i])
		if ret != expected[i] {
			t.Errorf("input is %d,the expected is %d", inputs[i], expected[i])
		}
	}
}
```

### 内置单元测试框架

* Fail,Errow：该测试失败，该测试（剩下的代码）继续，其他测试继续执行
* FailNow，Fatal：该测试失败，该测试（剩下的代码）中止，其他测试继续执行

```go
func TestError(t *testing.T) {
	fmt.Println("start")
	t.Error("Error")
	fmt.Println("end")
}
//output:
start
Error
end
func TestFatal(t *testing.T) {
	fmt.Println("start")
	t.Fatal("Error")
	fmt.Println("end")
}
//output:
start
end
```

* 在命令行下显示代码覆盖率

> go test -v -cover

* 断言引入

  go get -u github.com/stretchr/testify/assert

```go
func TestSquare(t *testing.T) {
	inputs := [...]int{1, 2, 3}
	expected := [...]int{2, 4, 9}
	for i := 0; i < len(inputs); i++ {
		ret := square(inputs[i])
		assert.Equal(t, ret, expected[i])
	}
}
```

```go
func TestSquareAssert(t *testing.T) {
	assert := assert.New(t)
	inputs := [...]int{1, 2, 3}
	expected := [...]int{1, 4, 9}
	for i := 0; i < len(inputs); i++ {
		ret := square(inputs[i])
		assert.Equal(ret, expected[i])
	}
}
```

## Benchmark

```go
func BenchmarkConcatStringByAdd(b *testing.B){
    //与性能测试无关的代码
    b.ResetTimer()
    for i:=0;i<b.N;i++{
        //测试代码
    }
    b.StopTimer()
    //与性能测试无关的代码
}
```

我们写两个Benchmark用来测试字符串的性能，如下：

```go
func BenchmarkConcatStringByAdd(b *testing.B) {
	elems := []string{"1", "2", "3"}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		ret := ""
		for _, elem := range elems {
			ret += elem
		}
	}
	b.StopTimer()
}

func BenchmarkConcatStringByBytesBuffer(b *testing.B) {
	elems := []string{"1", "2", "3"}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		var buf bytes.Buffer
		for _, elem := range elems {
			buf.WriteString(elem)
		}
	}
	b.StopTimer()
}
```

![](/media/hpsyche/_dde_data/note/go/极客时间/pict/6-1.png)

第一列表示运行次数，第二列表示平均每次执行时间（单位：纳秒）。

如果想知道代码片段memory allocate次数，可以加上-bench=. -benchmem，如下：

![](/media/hpsyche/_dde_data/note/go/极客时间/pict/6-2.png)

后两列分别为：每次操作分配的字节数、每次操作分配内存的次数。

可以看出：string加的操作会返回一个新的string，每个测试用例都会有2次分配操作，而通过byte的方式只有一次。

## BDD

前言见“测试-故事卡、BDD”。

在Go里面，BDD框架为goconvey

项目网站：https://github.com/smartystreets/goconvey

安装：go get -u github.com/smartystreets/goconvey

启动WEB UI：$GOPATH/bin/goconvey

首先有如下代码，其符合“Given-When-Then”风格：

```go
package bdd_test

import (
	"testing"
	. "github.com/smartystreets/goconvey/convey"
)

func TestBdd(t *testing.T) {
	Convey("Given 2 even numerbs", t, func() {
		a := 2
		b := 4
		Convey("When add the two numbers", func() {
			c := a + b
			Convey("Then the result is still even", func() {
				So(c%2, ShouldEqual, 0)
			})
		})
	})
}
```

注意：import . "github...."中的.代表是当前的命名空间下，就不需要重复convey.Convey了。

> go test -v：即可以看到详情信息。

需要将goconvey移动至当前目录下，./goconvey即可以看到goconvey路径下的所有测试类的UI界面。

