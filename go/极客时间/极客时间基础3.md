## Go面向对象？

准确的说,`Go` 既支持面向对象编程又不是面向对象语言!

是也不是,难道像是薛定谔的猫一样具有不确定性?其实这个答案是官方的回答。

```tex
Yes and no. Although Go has types and methods and allows an object-oriented style of programming, there is no type hierarchy. The concept of “interface” in Go provides a different approach that we believe is easy to use and in some ways more general. There are also ways to embed types in other types to provide something analogous—but not identical—to subclassing. Moreover, methods in Go are more general than in C++ or Java: they can be defined for any sort of data, even built-in types such as plain, “unboxed” integers. They are not restricted to structs (classes).

Also, the lack of a type hierarchy makes “objects” in Go feel much more lightweight than in languages such as C++ or Java.
```

为什么这么说呢?

`Go` 支持封装,却不支持继承和多态,所以严格按照面向对象规范来说, `Go` 语言不是面向对象的编程语言.

但是,`Go` 提供的接口是一种非常简单上手且更加通用的方式,虽然和其他主流的编程语言表现形式上略有不同,甚至不能实现多态,但 `Go` 的接口不仅仅适用于结构体,也可以适用于任何数据类型,这无疑是很灵活的!

争议性比较大的当属继承,由于没有任何关键字支持继承特性,因此是找不到继承的痕迹.虽然的确存在着某些方式可以将类型嵌入到其他类型中以实现子类化,但那却不是真正的继承.

所以说,`Go` 既支持面向对象的编程风格又不完全是面向对象的编程语言.

如果换个角度看问题的话,正是由于没有继承特性使得`Go` 相对于面向对象编程语言更加轻量化,不妨想一想继承的特性,子类和父类的关系,单继承还是多继承,访问控制权限等问题吧!

如果按照面向对象的编程规范,实现封装特性的那部分应该是类和对象,但这种概念与实现语言的关键字`class` 是密不可分的,然而 `Go` 并没有 `class` 关键字而是 `C` 语言家族的 `struct` 关键字,所以叫做类或对象也不是十分贴切。

### 结构体定义

```go
type Student struct {
	Id   string
	Name string
	Age  int
}
```

### 实例创建及初始化

```go
func TestStruct(t *testing.T) {
	e := Student{"0", "Mike", 20}
	fmt.Println(e)
	e1 := Student{Name: "Mary", Age: 30}
	fmt.Println(e1)
	// 注意，这里返回的是引用（指针），相当于e:=&Student{}
	e2 := new(Student)
	// e2 := &Student{}
	// 如c、cpp访问指针的成员的差异：不需要使用->
	e2.Name = "Messi"
	e2.Age = 34
	e2.Id = "1"
	fmt.Println(e2)
}
//output:
{0 Mike 20}
{ Mary 30}
&{1 Messi 34}
```

```go
func TestStruct2(t *testing.T) {
	e1 := Student{Name: "Mary", Age: 30}
	fmt.Printf("%T\n", e1)
	e2 := new(Student)
	// e2 := &Student{}
	// 如c、cpp访问指针的成员的差异：不需要使用->
	fmt.Printf("%T\n", e2)
}
//output:
struct_test.Student
*struct_test.Student
```

### 行为（方法）定义

与其他主流编程语言的差异

```go
func (s Student) String() string {
 	return fmt.Sprintf("ID:%s-Name:%s-Age:%d\n", s.Id, s.Name, s.Age)
}

func (s *Student) String() string {
	return fmt.Sprintf("ID:%s-Name:%s-Age:%d\n", s.Id, s.Name, s.Age)
}

func TestStruct3(t *testing.T) {
	e := Student{"0", "Mike", 20}
	fmt.Printf(e.String())
}
//output:
ID:0-Name:Mike-Age:20
```

其中：

* (s Student)的定义方式在实例对应方法被调用时，**实例的成员会进行复制**
* (s *Student)的定义避免了内存拷贝（推荐使用这种方式）

```go
func (s Student) String() string {
	fmt.Printf("Address is:%x\n", unsafe.Pointer(&s.Name))
	return fmt.Sprintf("ID:%s-Name:%s-Age:%d\n", s.Id, s.Name, s.Age)
}

func (s *Student) String() string {
    fmt.Printf("Address is:%x\n", unsafe.Pointer(&s.Name))
 	return fmt.Sprintf("ID:%s-Name:%s-Age:%d\n", s.Id, s.Name, s.Age)
}

func TestStruct3(t *testing.T) {
	s := Student{"0", "Mike", 20}
    fmt.Printf("Address is:%x\n", unsafe.Pointer(&s.Name))
	fmt.Printf(s.String())
}
```

其中：

* (s Student)的输出为：

  Address is:c000108340

  Address is:c000108370

  Student在传递进method时，实例的成员进行了复制，地址发生了改变

* (s *Student)的定义避免了内存拷贝（推荐使用这种方式）

  Address is:c00009a340

  Address is c00009a340

  Student在传递进method时，没有进行实例的拷贝，避免了内存的开销

## Duck Type式接口实现



鸭子类型：在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由当前方法和属性的集合决定。

在鸭子类型中，关注的不是对象的类型本身，而是它是如何使用的。例如，在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为鸭的对象，并调用它的走和叫方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的走和叫方法。如果这些需要被调用的方法不存在，那么将引发一个运行时错误。任何拥有这样的正确走和叫方法的对象都可被函数接受的这种行为引出了以上表述，这种决定类型的方式因此得名。

接口定义

```go
type Programmer interface {
	WriterHelloWorld() string
	WriterTest() int
}
```

接口实现

```go
type GoProgrammer struct {
}

func (p *GoProgrammer) WriterHelloWorld() string {
	return "fmt.Println(\"Hello World!\")"
}

func (p *GoProgrammer) WriterTest() int {
	return 123
}
```

```go
func TestClient(t *testing.T) {
	var p Programmer
	p = new(GoProgrammer)
	fmt.Println(p.WriterHelloWorld())
	fmt.Println(p.WriterTest())
}
//output:
fmt.Println("Hello World!")
123
```

### go接口

与其他主流编程语言的区别：

* 接口为非入侵性，实现不依赖于接口定义
* 所有接口的定义可以包含在接口使用者内

### 接口变量

![](/media/hpsyche/_dde_data/note/go/极客时间/pict/3-1.png)

## 自定义类型

* type IntConvertionFn func(n int) int
* type MyPoint int

```go
type myOwn func(op int) int

func timeSpeed(innerFn myOwn) myOwn {
	return func(n int) int {
		start := time.Now()
		innerFn(n)
		fmt.Println("time::", time.Since(start).Seconds())
		return n
	}
}
func slowFun(n int) int {
	time.Sleep(time.Second * 1)
	return 1
}

func TestFn(t *testing.T) {
	a := timeSpeed(slowFun)
	fmt.Println("return::", a(8))
}
```

## 多态

```go
package poly

import (
	"fmt"
	"testing"
)

type Code string

type Programmer interface {
	WriteHelloWorld() Code
}

type GoProgrammer struct {
}

func (P *GoProgrammer) WriteHelloWorld() Code {
	return "fmt.Println(\"Hello World\")"
}

type JavaProgrammer struct {
}

func (P *JavaProgrammer) WriteHelloWorld() Code {
	return "System.out.println(\"Hello World\")"
}

func WriteHelloWorld(P Programmer) Code {
	return P.WriteHelloWorld()
}

func TestPolymorphism(t *testing.T) {
	goP := new(GoProgrammer)
	fmt.Println(WriteHelloWorld(goP))
	javaP := new(JavaProgrammer)
	fmt.Println(WriteHelloWorld(javaP))
}
//output:
fmt.Println("Hello World")
System.out.println("Hello World")
```

## 空接口与断言

* 空接口可以表示任何类型

* 通过断言来将空接口转换为指定类型

  v,ok:=p.(int)

  //ok=true时转换成功

```go
package empty_interface_test

import (
	"fmt"
	"testing"
)

func EmptyInterface(p interface{}) {
	if i, ok := p.(int); ok {
		fmt.Println(ok, "Interger", i)
		return
	}
	if i, ok := p.(string); ok {
		fmt.Println(ok, "string", i)
		return
	}
	fmt.Println("Unknow Type")
}

func TestEmptyInterface(t *testing.T) {
	EmptyInterface(10)
	EmptyInterface(10.0)
}
//output:
true Interger 10
Unknow Type
```

```go
package empty_interface_test

import (
	"fmt"
	"testing"
)

func EmptyInterfaceSecond(p interface{}) {
	switch v := p.(type) {
	case int:
		fmt.Println("Integer", v)
	case string:
		fmt.Println("String", v)
	default:
		fmt.Println("Unknown Type", v)
	}
}

func TestEmptyInterfaceSecond(t *testing.T) {
	EmptyInterfaceSecond(10)
	EmptyInterfaceSecond(10.0)
}
//output:
Integer 10
Unknown Type 10
```

### Go接口最佳实践

* 倾向于使用小的接口定义，很多接口只包含一个方法

  ```go
  type Reader interface{
      Reader(p []byte)(n int,err error)
  }
  type Writer interface{
      Writer(p []byte)(n int,err error)
  }
  ```

* 较大的接口定义，可以由多个小接口定义组合而成

  ```go
  type ReadWriter interface{
      Reader
      Writer
  }
  ```

* 只依赖于必要功能的最小接口

  ```go
  func StoreData(reader Reader) error{
      
  }
  ```


## Go的错误机制

与其他主流编程语言的区别：

* 没有异常机制

* error类型实现了error接口

  ```go
  type error interface{
      Error() string
  }
  ```

* 可以通过errors.New来快速创建错误实例

  ```go
  errors.New("n must be in the range[0,10]")
  ```

```go
package error_test

import (
	"errors"
	"fmt"
	"testing"
)

var LessError = errors.New("n<2")
var MoreError = errors.New("n>10")

func GetFibonacci(n int) ([]int, error) {
	if n < 2 {
		return nil, LessError
	}
	if n > 10 {
		return nil, MoreError
	}
	list := []int{1, 1}
	for i := 2; i < n; i++ {
		list = append(list, list[i-1]+list[i-2])
	}
	return list, nil
}

func TestError(t *testing.T) {
	if v, err := GetFibonacci(6); err != nil {
		if err == LessError {
			fmt.Println("n<2")
			return
		}
		if err == MoreError {
			fmt.Println("n>10")
			return
		}
	} else {
		fmt.Println(v)
	}
}
```

### 减少嵌套，快速失败

```go
package two_error_test

import (
	"errors"
	"fmt"
	"strconv"
)

var LessError = errors.New("n<2")
var MoreError = errors.New("n>10")

func GetFibonacci(n int) ([]int, error) {
	if n < 2 {
		return nil, LessError
	}
	if n > 10 {
		return nil, MoreError
	}
	list := []int{1, 1}
	for i := 2; i < n; i++ {
		list = append(list, list[i-1]+list[i-2])
	}
	return list, nil
}

//快速失败，简洁雅观
func GetFibonacci1(str string) {
	var i int
	var err error
	var list []int
	if i, err = strconv.Atoi(str); err != nil {
		fmt.Println("error", err)
		return
	}
	if list, err = GetFibonacci(i); err != nil {
		fmt.Println("error", err)
		return
	}
	fmt.Println(list)

}

//若嵌套多层，代码很难看
func GetFibonacci2(str string) {
	if i, err := strconv.Atoi(str); err == nil {
		if list, err := GetFibonacci(i); err == nil {
			fmt.Println(list)
		} else {
			fmt.Println("error", err)
		}
	} else {
		fmt.Println("error", err)
	}
}
```

## panic

* panic用于不可以恢复的错误
* panic退出前会执行defer制定的内容

### panic vs. os.Exit

* os.Exit退出时不会调用defer指定的函数
* os.Exit退出时不输出当前调用栈信息

```go
func TestPanicVsExit(t *testing.T) {
	defer func() {
		fmt.Println("finally")
	}()
	fmt.Println("start")
	panic(errors.New("Something wrong!"))
}
//output:
start
finally
--- FAIL: TestPanicVsExit (0.00s)
panic: Something wrong! [recovered]
	panic: Something wrong!
```

```go
func TestPanicVsExit(t *testing.T) {
	defer func() {
		fmt.Println("finally")
	}()
	fmt.Println("start")
	os.Exit(-1)
}
//output:
start
exit status 255
```

## Recover

类似与java，go也有其异常捕获机制

```go
func TestRecover(t *testing.T) {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println("recover", err)
		}
	}()
	fmt.Println("start")
	panic(errors.New("Something Wrong!"))
}
//output:
start
recover Something Wrong!
```

### 最常见的“错误恢复”

```go
defer func(){
    if err:=recover();err!=nil{
        log.Error("recover paninc",err)
    }
}()
```

当心！recover可能会称为恶魔

* 形成僵尸服务进程（即看起来在提供服务，但实际已无力提供服务，资源耗尽等原因），导致health check失效；
* “let it crash！”往往是我们恢复不确定性错误的最好方法。

## 类型断言

**类型断言** 提供了访问接口值底层具体值的方式。

```
t := i.(T)
```

该语句断言接口值 `i` 保存了具体类型 `T`，并将其底层类型为 `T` 的值赋予变量 `t`。

**若 `i` 并未保存 `T` 类型的值，该语句就会触发一个恐慌。**

为了 **判断** 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。

```
t, ok := i.(T)
```

若 `i` 保存了一个 `T`，那么 `t` 将会是其底层值，而 `ok` 为 `true`。

否则，`ok` 将为 `false` 而 `t` 将为 `T` 类型的零值，程序并不会产生恐慌。

请注意这种语法和读取一个映射时的相同之处。

```go
func main(){
	var i interface{}="hello"
	s:=i.(string)
	fmt.Println(s)

	s,ok:=i.(string)
	fmt.Println(s,ok)

	f,ok:=i.(int)
	fmt.Println(f,ok)

	f=i.(int)
	fmt.Println(f)
}
//output:
hello
hello true
0 false
panic: interface conversion: interface {} is string, not int
```

### 类型选择

```go
switch v := i.(type) {
case T:
    // v 的类型为 T
case S:
    // v 的类型为 S
default:
    // 没有匹配，v 与 i 的类型相同
}
```

