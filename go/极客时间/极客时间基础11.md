## GC友好的代码

### 避免内存分配和复制

* 复杂对象尽量传递引用
  * 数据的传递
  * 结构体传递

#### 示例

```go
package passing_ref

import "testing"

const NumOfElems=10000

type Content struct {
	Detail [10000]int
}

func withValue(arr [NumOfElems]Content) int{
	return 0
}

func withReference(arr *[NumOfElems]Content) int{
	return 0
}

func BenchmarkPassingArrayWithValue(b *testing.B){
	var arr [NumOfElems]Content
	b.ResetTimer()
	for i:=0;i<b.N;i++{
		withValue(arr)
	}
	b.StopTimer()
}

func BenchmarkPassingArrayWithRef(b *testing.B){
	var arr [NumOfElems]Content
	b.ResetTimer()
	for i:=0;i<b.N;i++{
		withReference(&arr)
	}
	b.StopTimer()
}
```

结果如下：

BenchmarkPassingArrayWithValue-8               8         132577516 ns/op
BenchmarkPassingArrayWithRef-8          1000000000               0.281 ns/op

### 打开GC日志

只要在程序执行之前加上环境变量GODEBUG=gctrace=1，

如GODEBUG=gctrace=1 go test -beach=.

​	GODEBUG=gctrace=1 go run main.go

日志详细信息参考：https://godoc.org/runtime

查看以上示例的-bench=BenchmarkPassingArrayWithValue

8         149752931 ns/op

查看以上示例的-bench=BenchmarkPassingArrayWithRef

1000000000               0.280 ns/op

### go tool trace

测试程序输出trace信息

go test -trace trace.out

可视化trace信息

go tool trace.out

如对于以上程序，可以：

go test -bench=BenchmarkPassingArrayWithValue -trace=trace_value.out

go test -bench=BenchmarkPassingArrayWithRef -trace=trace_ref.out

生成trace信息，再通过go tool可视化信息

go tool trace trace_value.out 

go tool trace trace_ref.out 

普通程序输出trace信息

```go
package main
import (
	"os"
    "runtime/trace"
)

func main(){
    f,err:=os.Create("trace.out")
    if err!=nil{
        panic(err)
    }
    defer f.Close()
    
    err=trace.Start(f)
    if err!=nil{
        panic(err)
    }
    defer trace.Stop()
    //Your program here
}
```

### 避免内存分配和复制

* 初始化至合适的大小
  * 自动扩容是有代价的
* 复用内存

