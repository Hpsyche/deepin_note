## 反射编程

reflect.TypeOf vs. reflect.ValueOf

* reflect.TypeOf返回类型（reflect.Type）
* reflect.ValueOf返回值（reflect.Value）
* 可以从reflect.Value获得类型
* 通过kind来判断类型

### 判断类型-Kind()

```go
const(
	Invalid Kind=iota
    Bool
    Int
    Int8
    Int16
    Int32
    Int64
    Uint
    Uint8
    Uint16
    Uint32
    Uint64
    ...
)
```

示例1，变量类型

```go
func TestTypeAndValue(t *testing.T){
	var f int64=10
	t.Log(reflect.TypeOf(f),reflect.ValueOf(f))
	t.Log(reflect.ValueOf(f).Type())
}
//output:
int64 10
int64
```

示例2，Kind的应用

```go
func CheckType(v interface{}){
	t:=reflect.TypeOf(v)
	switch t.Kind() {
	case reflect.Float32,reflect.Float64:
		fmt.Println("Float")
	case reflect.Int,reflect.Int32,reflect.Int64:
		fmt.Println(("Integer"))
	default:
		fmt.Println("Unknown",t)
	}
}

func TestBasicType(t *testing.T){
	var f float64 = 12
	CheckType(f)
}
//output:
Float
```

### 利用反射编写灵活的代码

* 按名字访问结构的成员

  reflect.ValueOf(* e).FieldByName("Name")

* 按名字访问结构的方法

  reflect.ValueOf(* e).MethodByName("UpdateAge").Call([]reflect.Value{reflect.ValueOf(1)})

```go
type Employee struct{
	EmployeeId string
	Name string
	Age int
}

func (e Employee) UpdateAge(newVal int){
	e.Age=newVal
}

func TestInvokeByName(t *testing.T){
	e:=&Employee{"1","Amy",20}
    //true
	//fmt.Println(reflect.ValueOf(e).Elem().CanSet())
	//false
    //fmt.Println(reflect.ValueOf(*e).CanSet())
	fmt.Printf("Name:value(%[1]v),Type(%[1]T)\n",reflect.ValueOf(*e).FieldByName("Name"))
	reflect.ValueOf(*e).MethodByName("UpdateAge").
		Call([]reflect.Value{reflect.ValueOf(1)})
	fmt.Println("New Age:",e.Age)
}
//output:
Name:value(Amy),Type(reflect.Value)
New Age: 1
```

### Elem介绍

注意：通过反射reflect.ValueOf(v)获取整型变量地址的反射值（即指针的值），需要再通过`Elem()`得到指针指向的具体对象，这样才可以修改值。

```go
func TestElem(t *testing.T){
	a:=1
	b:=reflect.ValueOf(a)
	fmt.Println(b.Type())
	fmt.Println(b.CanSet())
	b=reflect.ValueOf(&a)
	fmt.Println(b.Type())
	fmt.Println(b.CanSet())
	b=b.Elem()
	fmt.Println(b.Type())
	fmt.Println(b.CanSet())
}
//output:
int
false
*int
false
int
true
```

### Struct Tag

```go
type BasicInfo struct{
    Name string `json:"name"`
    Age int `json:"age"`
}
```

其中json:name和json:age即为Struct Tag。

可以通过反射获取Tag的值，如下：

```go
type Employee struct{
	EmployeeId string
	Name string `format:"normal"`
	Age int
}
func TestInvokeByName(t *testing.T){
	e:=&Employee{"1","Amy",20}
	if nameField,ok:=reflect.TypeOf(*e).FieldByName("Name");!ok{
        fmt.Println("Failed to get 'Name' field")
    }else{
        fmt.Println("Tag:format",nameField.Tag.Get("format"))
    }
}
//output:
Tag:format normal
```

## DeepEqual

### 比较切片和Map

```go
func TestDeepEqual(t *testing.T){
	a:=map[int]string{1:"one",2:"two",3:"three"}
	b:=map[int]string{1:"one",2:"two",3:"three"}
	//map can only be compared to nil
    //fmt.Println(a==b)
	fmt.Println(reflect.DeepEqual(a,b))
}
//output:
true
```

## 反射应用

### 对象赋值

```go
type Employee struct {
	EmployeeId string
	Name string
	Age int
}
type Customer struct {
	CustomerId string
	Name string
	Age int
}
func fillUtils(st interface{}, setting map[string]interface{}) interface{} {
	if reflect.TypeOf(st).Kind()!=reflect.Ptr{
		if reflect.TypeOf(st).Elem().Kind()!=reflect.Struct{
			return errors.New("the first param should be a pointer to the struct type")
		}
	}
	if setting==nil{
		return errors.New("setting is nil")
	}
	var (
		field reflect.StructField
		ok bool
	)
	//反射找到对象的指针所在位置
	vstr:=reflect.ValueOf(st)
	//找到指向的具体对象
	vstr=vstr.Elem()
	for k,v:=range setting{
		//如果结构体不存在此属性，continue
		if field,ok=reflect.ValueOf(st).Elem().Type().FieldByName(k);!ok{
			continue
		}
		if field.Type==reflect.TypeOf(v){
			vstr.FieldByName(k).Set(reflect.ValueOf(v))
		}

	}
	return nil
}

func TestFillValue(t *testing.T){
	setting:=map[string]interface{}{"Name":"Amy","Age":20}
	e:=&Employee{}
	if err:=fillUtils(e,setting);err!=nil{
		t.Fatal(err)
	}
	t.Log(e)
	c:=&Customer{}
	if err:=fillUtils(c,setting);err!=nil{
		t.Fatal(err)
	}
	t.Log(c)
}
//output:
&{ Amy 20}
&{ Amy 20}
```

### Dto to Vo

```go
type EmployeeDto struct {
	EmployeeId string
	Name string
	Age int
}


type EmployeeVo struct {
	Name string
	Age int
	date string
}

func DtoToVoSecond(dto interface{},vo interface{}) {
	dtoPtr:=reflect.ValueOf(dto).Elem()
	dtoType :=dtoPtr.Type()
	num:= dtoPtr.NumField()
	//反射找到vo对象的指针所在位置
	voPtr := reflect.ValueOf(vo)
	//找到指向的具体对象
	voPtr = voPtr.Elem()
	var (
		field reflect.StructField
		ok bool
	)
	for i:=0;i<num;i++{
		curr:= dtoType.Field(i)
		if field,ok=voPtr.Type().FieldByName(curr.Name);!ok{
			continue
		}
		if field.Type==curr.Type{
			voPtr.FieldByName(curr.Name).Set(dtoPtr.Field(i))
		}
	}
}

func TestDtoToVoSecond(t *testing.T){
	e1:=&EmployeeDto{"1","Amy",20}
	e2:=&EmployeeVo{}
	DtoToVoSecond(e1,e2)
	fmt.Println(e2)
}
//output:
&{Amy 20 }
```

