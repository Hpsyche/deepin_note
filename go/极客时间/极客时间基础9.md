## 性能分析工具

### 准备工作

* 安装graphviz

  apt-get install graphviz

* 安装go-torch

  go get github.com/uber/go-torch

  下载并复制https://github.com/brendangregg/FlameGraph/edit/master下的flamegraph.pl至$GOPATH/bin路径下

### 通过文件方式输出Profile

* 灵活性高，适用于特定代码段的分析
* 通过手动调用runtime/pprof的API

#### 示例

```go
package main

import (
	"log"
	"math/rand"
	"os"
	"runtime/pprof"
	"time"
)

const(
	row=10000
	col=10000
)

func fillMatrix(m *[row][col]int){
	s:=rand.New(rand.NewSource(time.Now().UnixNano()))
	for i:=0;i< row;i++{
		for j := 0; j < col; j++ {
			m[i][j]=s.Intn(100000)
		}
	}
}

func calculate(m *[row][col]int){
	for i := 0; i < row; i++ {
		temp:=0
		for j := 0; j < col; j++ {
			temp+=m[i][j]
		}
	}
}

func main(){
	//创建输出文件
	f,err:=os.Create("cpu.prof")
	if err!=nil{
		log.Fatal("could not create cpu profile:",err)
	}
	//监控CPU
	if err:=pprof.StartCPUProfile(f);err!=nil{
		log.Fatal("could not start CPU profile:",err)
	}
	defer pprof.StopCPUProfile()
	x:=[row][col]int{}
	fillMatrix(&x)
	calculate(&x)

	f1,err:=os.Create("mem.prof")
	if err!=nil{
		log.Fatal("could not create memory profile:",err)
	}
	//runtime.GC()
	if err:=pprof.WriteHeapProfile(f1);err!=nil{
		log.Fatal("could not start memory profile:",err)
	}
	f1.Close()

	f2,err:=os.Create("goroutine.prof")
	if err!=nil{
		log.Fatal("could not create goroutine profile:",err)
	}
	if gProf:=pprof.Lookup("goroutine");gProf==nil{
		log.Fatal("could not start goroutine profile")
	}else{
		gProf.WriteTo(f2,0)
	}
	f2.Close()
}
```

通过go build prof.go，./prof，目录下即生成三个文件：CPU、内存、协程信息

通过go tool pprof prof cpu.prof查看cpu信息

![](/media/hpsyche/_dde_data/note/go/极客时间/pict/9-1.png)

通过top查看信息，top -cum：按cum降序显示

![](/media/hpsyche/_dde_data/note/go/极客时间/pict/9-2.png)

list 某个方法，可以看到具体耗时的步骤。

对于mem.prof也同样如此。

![](/media/hpsyche/_dde_data/note/go/极客时间/pict/9-3.png)

当添加runtime.GC()后，发现基本不占用任何内存。

### 通过HTTP方式输出Profile

以上方式较适用于短时间批量运行的，对于我们的服务器端程序，长时间在运行，我们不方便令其持续输出prof，如果想在运行中看prof，可以通过下面的方式实现。

* 简单，适用于持续性运行的应用
* 在应用程序中导入import _ 'net/http/pprof'，并启动http server即可
* http://<host>:<port>/debug/pprof
* go tool pprof _http://<host>:<port>/debug/pprof/profile?seconds=10（默认值为30秒）

#### 示例

```go
package main

import (
	"fmt"
	"log"
	"net/http"
    //导入pprof性能分析工具
	_ "net/http/pprof"
)

func GetFibonacciSeries(n int)[]int{
	ret:=make([]int,2,n)
	ret[0]=1
	ret[1]=1
	for i:=2;i<n;i++{
		ret=append(ret,ret[i-1]+ret[i-1])
	}
	return ret
}

func main(){
	http.HandleFunc("/",index)
	http.HandleFunc("/fb",createFBS)
	log.Fatal(http.ListenAndServe(":8081",nil))
}

func createFBS(writer http.ResponseWriter, request *http.Request) {
	var fbs[]int
	for i:=0;i<100000;i++{
		fbs=GetFibonacciSeries(50)
	}
	writer.Write([]byte(fmt.Sprintf("%v",fbs)))
}

func index(writer http.ResponseWriter, request *http.Request) {
	writer.Write([]byte("Welcome!"))
}
```

在浏览器中：http://localhost:8081/debug/pprof/，可以通过各个路径

![](/media/hpsyche/_dde_data/note/go/极客时间/pict/9-4.png)

通过命令行：go tool pprof http://localhost:8081/debug/pprof/profile获得profile的性能分析（url最后的profile可以换成其他，以分析其他区域的性能）。

默认为30s，在30s内我们多次访问http://localhost:8081/debug/pprof/，30s后将输出分析结果，如下：

![](/media/hpsyche/_dde_data/note/go/极客时间/pict/9-5.png)

## 性能调优示例

![](/media/hpsyche/_dde_data/note/go/极客时间/pict/9-6.png)

### 常见分析指标

* Wall Time
* CPU Time
* Block Time
* Memory allocation
* GC times/time spent

### 案例

结构体：

 ```go
type Request struct {
	TransactionID string `json:"transaction_id"`
	PayLoad []int `json:"payload"`
}

type Response struct {
	TransactionID string `json:"transaction_id"`
	Expression string `json:"exp"`
}
 ```

主程序：

```go
package ch22

import (
	"encoding/json"
	_ "net/http"
	"strconv"
)

func createRequest() string{
	payload:=make([]int,100,100)
	for i:=0;i<100;i++{
		payload[i]=i
	}
	exp:=Request{"demo_transaction",payload}
	v,err:=json.Marshal(&exp)
	if err!=nil{
		panic(err)
	}
	return string(v)
}

func processRequest(reqs []string) []string{
	reps:=[]string{}
	for _,req:=range reqs{
		reqObj:=&Request{}
		json.Unmarshal([]byte(req),reqObj)
		ret:=""
		for _,e:=range reqObj.PayLoad{
			ret+=strconv.Itoa(e)+","
		}
		repObj:=&Response{reqObj.TransactionID,ret}
		repJson,err:=json.Marshal(&repObj)
		if err!=nil{
			panic(err)
		}
		reps=append(reps,string(repJson))
	}
	return reps
}
```

测试类：

```go
package ch22

import "testing"

func TestCreateRequest(t *testing.T){
	str:=createRequest()
    //output:
    //[{"transaction_id":"demo_transaction","exp":"0,1,2,3,...
	t.Log(str)
}

func TestProcessRequest(t *testing.T){
	reqs:=[]string{}
	reqs=append(reqs,createRequest())
	reps:=processRequest(reqs)
    //output:
    //[{"transaction_id":"demo_transaction","exp":"0,1,2,3,...
	t.Log(reps)
}

func BenchmarkProcessRequest(b *testing.B){
	reqs:=[]string{}
	reqs=append(reqs,createRequest())
	b.ResetTimer()
	for i:=0;i<b.N;i++{
		processRequest(reqs)
	}
	b.StopTimer()
}
```

go test -bench=. 运行结果如下：

BenchmarkProcessRequest-8          29732             40029 ns/op

通过go test -bench=. -cpuprofile=cpu.prof，生成cpu性能分析文件。

同样以go tool pprof cpu.prof 进入prof命令，通过top+list命令得出json.Unmarshal较为耗时。

进行调优，使用easyjson而不是反射。

执行easyjson -all structs.go，生成structs的json工具函数

将源代码中json转换的代码进行替换。

再次测试，运行结果如下：

BenchmarkProcessRequest-8          62733             18488 ns/op

此时发现ret+=strconv.Itoa为耗时最多的代码，我们进一步调优。

也可以通过go test -bench=. -memprofile=mem.prof看到这里内存空间占用很大。 

 961.69MB   961.69MB     48:                   ret+=strconv.Itoa(e)+","

由于string的直接相加会导致复制内存，allocate等频繁的操作，我们可以使用builder来代替。

修改如下：

```go
func processRequest(reqs []string) []string{
	reps:=[]string{}
	for _,req:=range reqs{
		reqObj:=&Request{}
		reqObj.UnmarshalJSON([]byte(req))
		var buf strings.Builder
		for _,e:=range reqObj.PayLoad{
			buf.WriteString(strconv.Itoa(e))
			buf.WriteString(",")
		}
		repObj:=&Response{reqObj.TransactionID,buf.String()}
		repJson,err:=repObj.MarshalJSON()
		if err!=nil{
			panic(err)
		}
		reps=append(reps,string(repJson))
	}
	return reps
}
```

再次测试，运行结果如下：

BenchmarkProcessRequest-8         119767              9945 ns/op

性能再次提高，查看内存：

    39.01MB     49:                   buf.WriteString(strconv.Itoa(e))
    73.03MB     50:                   buf.WriteString(",")
最后进行对比：

BenchmarkProcessRequest-8         123378              9793 ns/op
BenchmarkOldProcessRequest-8       40382             28453 ns/op

效率大大提高！

