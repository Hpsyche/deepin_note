## 别让性能“锁”住

* 减少锁的影响范围
* 减少发生锁冲突的概率
  * sync.Map
  * ConcurrentMap
* 避免锁的使用
  * LAMX Disruptor：https://martinfowler.com/articles/lmax.html

### 示例

定义三个锁类操作map，进行测试。

读写锁

```go
package ch23

import "sync"

type RWLockMap struct {
	m map[interface{}]interface{}
	lock sync.RWMutex
}

func (m *RWLockMap) Get(key interface{}) (interface{},bool){
	m.lock.Lock()
	v,ok:=m.m[key]
	m.lock.Unlock()
	return v,ok
}

func (m *RWLockMap) Set(key interface{},value interface{}){
	m.lock.Lock()
	m.m[key]=value
	m.lock.Unlock()
}

func (m *RWLockMap) Del(key interface{}){
	m.lock.Lock()
	delete(m.m,key)
	m.lock.Unlock()
}

func CreateRWLockMap() *RWLockMap{
	m:=make(map[interface{}]interface{},0)
	return &RWLockMap{m:m}
}
```

同步锁

```go
package ch23

import "sync"

type SyncMap struct {
	m sync.Map
}

func (m* SyncMap) Set(key interface{},val interface{}){
	m.m.Store(key,val)
}

func (m *SyncMap) Get(key interface{}) (interface{},bool){
	return m.m.Load(key)
}

func (m *SyncMap) Del(key interface{}){
	m.m.Delete(key)
}

func CreateSyncMap() *SyncMap{
	return &SyncMap{}
}
```

并发锁

```go
package ch23

import "github.com/easierway/concurrent_map"

type ConcurrentMap struct {
	m *concurrent_map.ConcurrentMap
}

func (m *ConcurrentMap) Set(key interface{},val interface{}){
	m.m.Set(concurrent_map.StrKey(key.(string)),val)
}

func (m *ConcurrentMap) Get(key interface{}) (interface{},bool){
	return m.m.Get(concurrent_map.StrKey(key.(string)))
}

func (m *ConcurrentMap) Del(key interface{}){
	m.m.Del(concurrent_map.StrKey(key.(string)))
}

func CreateConcurrentMap(numOfPartitions int) *ConcurrentMap{
	conMap:=concurrent_map.CreateConcurrentMap(numOfPartitions)
	return &ConcurrentMap{conMap}
}
```

测试类

```go
package ch23

import (
	"strconv"
	"sync"
	"testing"
)

const(
	NumOfReader=10
	NumOfWriter=100
)

type Map interface{
	Set(key interface{},val interface{})
	Get(key interface{})(interface{},bool)
	Del(key interface{})
}

func benchmarkMap(b *testing.B,hm Map){
	for i:=0;i<b.N;i++{
		var wg sync.WaitGroup
		for i:=0;i<NumOfWriter;i++{
			wg.Add(1)
			go func(){
				for i:=0;i<100;i++{
					hm.Set(strconv.Itoa(i),i*i)
					hm.Set(strconv.Itoa(i),i*i)
					hm.Del(strconv.Itoa(i))
				}
				wg.Done()
			}()
		}
		for i:=0;i<NumOfReader;i++{
			wg.Add(1)
			go func(){
				for i:=0;i<100;i++{
					hm.Get(strconv.Itoa(i))
				}
				wg.Done()
			}()
		}
		wg.Wait()
	}
}


func BenchmarkMap(b *testing.B){
	b.Run("map with RWLock", func(b *testing.B) {
		hm:=CreateRWLockMap()
		benchmarkMap(b,hm)
	})

	b.Run("sync.map", func(b *testing.B) {
		hm:=CreateSyncMap()
		benchmarkMap(b,hm)
	})

	b.Run("concurrent map", func(b *testing.B) {
		hm:=CreateConcurrentMap(199)
		benchmarkMap(b,hm)
	})
}
```

go test -bench=.进行测试（NumOfReader=10，NumOfWriter=100），运行结果如下：

BenchmarkMap/map_with_RWLock-8               199           5745580 ns/op
BenchmarkMap/sync.map-8                      152           8616214 ns/op
BenchmarkMap/concurrent_map-8                382           2931429 ns/op

发现当写多读少时，concurrent_map效率高。

（NumOfReader=100，NumOfWriter=100），运行结果如下：

BenchmarkMap/map_with_RWLock-8               178           7154008 ns/op
BenchmarkMap/sync.map-8                      129           9092051 ns/op
BenchmarkMap/concurrent_map-8                297           4065831 ns/op

当读写差不多时，concurrent_map效率高。

（NumOfReader=1000，NumOfWriter=10），运行结果如下：

BenchmarkMap/map_with_RWLock-8               189           6293340 ns/op
BenchmarkMap/sync.map-8                      289           3734371 ns/op
BenchmarkMap/concurrent_map-8                201           5998499 ns/op

发现syncMap为最佳选择。

