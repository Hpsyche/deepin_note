## “不安全”编程

###　“不安全”行为的危险性

```go
i:=10
f:=*(*float64)(unsafe.Pointer(&i))
```

例１：

```go
func TestUnsafe(t *testing.T){
	i:=10;
	f:=*(*float64)(unsafe.Pointer(&i))
	t.Log(unsafe.Pointer(&i))
	t.Log(f)
}
//output:
0xc0001181b0
5e-323
```

例２：

```go
type MyInt int

//合理的类型转换
func TestConvert(t *testing.T){
	a:=[]int{1,2,3,4}
	b:=*(*[]MyInt)(unsafe.Pointer(&a))
	t.Log(b)
}
//output:
[1 2 3 4]
```

例三:

```go
//原子类型的操作
func TestAtomic(t *testing.T){
	var shareBufPtr unsafe.Pointer
	writeDataFn:= func() {
		data:=[]int{}
		for i:=0;i<100;i++{
			data=append(data,i)
		}
		atomic.StorePointer(&shareBufPtr,unsafe.Pointer(&data))
	}
	readDataFn:= func() {
		data:=atomic.LoadPointer(&shareBufPtr)
		fmt.Println(data,*(*[]int)(data))
	}
	var wg sync.WaitGroup
	writeDataFn()
	for i:=0;i<10;i++{
		wg.Add(1)
		go func() {
			writeDataFn()
			time.Sleep(time.Microsecond*100)
			wg.Done()
		}()
		wg.Add(1)
		go func(){
			readDataFn()
			time.Sleep(time.Microsecond*100)
			wg.Done()
		}()
	}
	wg.Wait()
}
//output:
0xc00000c0c0 [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99]
0xc00000c100 [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99]
0xc00000c160 [0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99]
......
```

## Pipe-Filter模式

* 非常适合与数据处理及数据分析系统

* Filter封装数据处理的功能

* 松耦合：Filter只跟数据（格式）耦合

* Pipe用于连接Filter传递数据或者在异步处理过程中缓冲数据流

  进程内同步调用时，pipe演变为数据在方法调用间传递

![](/media/hpsyche/_dde_data/note/go/go基础/pict/8-1.png)

![](/media/hpsyche/_dde_data/note/go/go基础/pict/8-2.png)

通过Fiilter+组合模式，实现数据的过滤清洗和处理

具体如下：

首先是Filter接口的定义

```go
type Request interface {
}
type Response interface {
}
type Filter interface {
	Process(data Request)(Response,error)
}
```

SplitFilter，切割字符串过滤器

```go
var SplitFilterWrongFormatError=errors.New("input data show be string")

type SplitFilter struct {
	delimiter string
}

func NewSplitFilter(delimiter string) *SplitFilter{
	return &SplitFilter{delimiter}
}

func (sf *SplitFilter) Process(data Request)(Response,error){
	//检查数据格式：是否为string
	str,ok:=data.(string)
	if !ok{
		return nil,SplitFilterWrongFormatError
	}
	parts:=strings.Split(str,sf.delimiter)
	return parts,nil
}
```

ToIntFilter，转换成int过滤器

```go
var ToIntFilterWrongFormatError=errors.New("input data should be []string")
type ToIntFilter struct{
}
func NewToIntFilter() *ToIntFilter{
	return &ToIntFilter{}
}

func (tif *ToIntFilter) Process(data Request)(Response,error){
	parts,ok:=data.([]string)
	if !ok{
		return nil,ToIntFilterWrongFormatError
	}
	ret:=[]int{}
	for _,part:=range parts{
		s,err:=strconv.Atoi(part)
		if err!=nil{
			return nil, err
		}
		ret=append(ret,s)
	}
	return ret,nil
}
```

SumFilter，求和过滤器

```go
var SumFilterWrongFormatError=errors.New("input data should be []int")

type SumFilter struct {
}
func NewSumFilter() *SumFilter{
	return &SumFilter{}
}
func(s *SumFilter)Process(data Request) (Response,error){
	elems,ok:=data.([]int)
	if !ok{
		return nil,SumFilterWrongFormatError
	}
	ret:=0;
	for _,elem:=range elems{
		ret+=elem
	}
	return ret,nil
}
```

StraightPipeline，串行管道，将数据逐个通过Filter过滤处理

```go
type StraightPipeline struct{
	Name string
	Filters *[]Filter
}

func NewStraightPipeline(name string,filters ...Filter) *StraightPipeline{
	return &StraightPipeline{Name: name,Filters: &filters}
}

func (f *StraightPipeline) Process(data Response)(Response,error){
	var ret interface{}
	var err error
	for _,filter:=range *f.Filters{
		ret,err=filter.	Process(data)
		if err!=nil{
			return ret, err
		}
		//回写data，进行下一次filter
		data=ret
	}
	return ret,err
}
```

测试类

```go
func TestStraightPipeline_Process(t *testing.T) {
	spliter:=NewSplitFilter(",")
	toIntFilter:=NewToIntFilter()
	sumFilter:=NewSumFilter()
	sp:=NewStraightPipeline("sp1",spliter,toIntFilter,sumFilter)
	ret, err := sp.Process("1,2,6")
	if err!=nil{
		t.Fatal(err)
	}
	fmt.Println(ret)
}
//output:
9
```

## 更快的JSON解析

EasyJson

其采用代码生成而非反射

安装：go get -u github.com/mailru/easyjson/...

使用：easyjson -all <结构定义>.go

如我们有如下结构定义文件

```go
package easyjson

type BasicInfo struct {
	Name string `json:"name"`
	Age int `json:"age"`
}

type JobInfo struct {
	Skills []string `json:"skills"`
}

type Employee struct {
	BasicInfo BasicInfo `json:"basic_info"'`
	JobInfo JobInfo `json:"job_info"`
}
```

在此目录下执行： ~/go/bin/easyjson -all struct_def.go 

即可生成EasyJson的接口文件类。

可以测试二者的性能差距

```go
func BenchmarkEmployeeEasyJson(b *testing.B) {
	b.ResetTimer()
	e:=Employee{}
	for i:=0;i<b.N;i++{
		err:=e.UnmarshalJSON([]byte(str))
		if err!=nil{
			b.Error(err)
		}
		if _,err=e.MarshalJSON();err!=nil{
			b.Error(err)
		}
	}
}

func BenchmarkEmployeeEmbeddedJson(b *testing.B) {
	b.ResetTimer()
	e:=&Employee{}
	for i:=0;i<b.N;i++{
		err:=json.Unmarshal([]byte(str),e)
		if err!=nil{
			b.Error(err)
		}
		if _,err=json.Marshal(e);err!=nil{
			b.Error(err)
		}
	}
}
```

> go test -bench=.

BenchmarkEmployeeEasyJson-8      1239880               990 ns/op
BenchmarkEmployeeEmbeddedJson-8       307146              3600 ns/op

可以发现EasyJson的速度快了很多。

## HTTP服务

```go
func main(){
	http.HandleFunc("/", func(writer http.ResponseWriter, request *http.Request) {
		fmt.Fprintf(writer,"Hello World!")
	})
	http.HandleFunc("/time", func(writer http.ResponseWriter, request *http.Request) {
		t:=time.Now()
		timeStr:=fmt.Sprintf("{\"time\":\"%s\"}",t)
		writer.Write([]byte(timeStr))
	})
	http.ListenAndServe(":8080",nil)
}
```

访问：http://127.0.0.1:8080，显示hello world!

访问：http://127.0.0.1:8080/time，显示

{"time":"2020-05-08 20:22:01.600204044 +0800 CST m=+145.056241099"}

访问：http://127.0.0.1:8080/time/2，显示hello world!

原因？

```go
func (sh serverHandler) ServeHttp(rw ResponseWriter,req *Request){
    handler := sh.srv.Handler
    if handler==nil{
        //使用缺省的Router
        handler=DefaultServeMux
    }
    if req.RequestURI=="*"&&req.Method=="OPTIONS"{
        handler=globalOptionsHandler{}
    }
    handler.ServeHTTP(rw,req)
}
```

### 路由规则

* URL分为两种，末尾是/：表示一个子树，后面可以跟其他子路径；末尾不是/，表示一个叶子，固定的路径

  以/结尾的URL可以匹配它的任何子路径，比如/images/会匹配/images/cute-cat.jpg
  
* 它采用最长匹配原则，如果有多个匹配，一定采用匹配路径最长的那个进行处理

* 如果没有找到任何匹配项，会返回404错误

## 构建Restful服务

### 更好的Router

http://github.com/julienschmidt/httprouter

```go
func Hello(w http.ResponseWriter,r *http.Request,ps httprouter.Params){
    fmt.Fprintf(w,"hello,%s!\n",ps.ByName("name"))
}
func main(){
    router:=httprouter.New()
    router.GET("/",Index)
    router.GET("/hello/:name",Hello)
    
    log.Fatal(http.ListenAndServe(":8080",router))
}
```

使用：

```go
func main(){
	router:=httprouter.New()
	router.GET("/",Index)
	router.GET("/hello/:name",Hello)
	log.Fatal(http.ListenAndServe(":8080",router))
}

func Hello(writer http.ResponseWriter, request *http.Request, params httprouter.Params) {
	fmt.Fprintf(writer,"Hello,%s!",params.ByName("name"))
}

func Index(writer http.ResponseWriter, request *http.Request, params httprouter.Params) {
	fmt.Fprint(writer,"Hello World!")
}
```

类似database取数据，转json：

```go
package main

import (
	"encoding/json"
	"fmt"
	"github.com/julienschmidt/httprouter"
	"log"
	"net/http"
)

type Employee struct {
	ID string `json:"id"`
	Name string `json:"name"`
	Age int `json:"age"`
}
var employeeDB map[string]*Employee

func init(){
	employeeDB = map[string]*Employee{}
	employeeDB["Mike"]=&Employee{"e-1","Mike",20}
	employeeDB["Amy"]=&Employee{"e-2","Amy",18}
}

func Index(writer http.ResponseWriter, request *http.Request, params httprouter.Params) {
	fmt.Fprint(writer,"Hello World!")
}

func GetEmployeeByName(writer http.ResponseWriter, request *http.Request, params httprouter.Params){
	qName:=params.ByName("name")
	var(
		ok bool
		info *Employee
		infoJson []byte
		err error
	)
	if info,ok=employeeDB[qName];!ok{
		writer.Write([]byte("{\"error\":\"Not found\"}"))
		return
	}
	if infoJson,err=json.Marshal(info);err!=nil{
		writer.Write([]byte(fmt.Sprintf("{\"error\":\"%s\"}",err)))
		return
	}
	writer.Write(infoJson)
}

func main(){
	router:=httprouter.New()
	router.GET("/",Index)
	router.GET("/employee/:name",GetEmployeeByName)
	log.Fatal(http.ListenAndServe(":8080",router))
}
```





