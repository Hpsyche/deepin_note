## Go特性

### 并发编程

* Go语言在并发编程方面比绝大多数语言要简洁不少，这是其最大亮点之一，而是其未来进入高并发高性能常见的重要筹码；
* golang的并发执行单元是一种称为goroutine的协程，协程一般由应用程序显示调度，上下文切换无需设计到内核层，高效不少，协程间的通信靠独有的channel机制实现；

### GC

* 内存自动回收，不需要开发人员管理内存
* 开发人员专注业务实现，降低了心智负担
* 只需要new分配内存，不需要释放

GC过程：先stop the world，扫描所有对象判活，把可回收对象在一段bitmap区中标记下来，接着立即start the world恢复服务，同时起一个专门goroutine，回收内存到空闲list中以备复用，不物理释放，物理释放由专门线程定期来执行；

GC瓶颈自傲与每次都要扫描所有对象来判活，待收集的对象数目越多，速度越慢，GC性能可能随着版本不断更新会不断优化；

### 内存分配

* 先分配一块大内存区域；
* 大内存被切分成各个大小等级的块，放入不同的空闲list中；
* 对象分配空间时从空闲list中取出大小合适的内存块；
* 内存回收时，会把不同的内存重放回空闲list；
* 空闲内存会按照一定策略合并，以减少碎片。

### 编译

目前Golang具有两种编译器：

* 一种是建立在GCC基础上的Gccgo
* 另外一种是分别针对64位x64和32位x86计算机的一套编译器

### 网络编程

* socket用net.Dial（基于tcp、udp，封装了传统的connect、listen、accept等接口）
* http用http.Get/Post()
* rpc用client.Class()

在Go语言中还有一个很重要的能力，自带高性能httpServer，通过简单的几行代码调用，就可以得到一个基于协程的高性能Web服务，更重要的是，维护成本极低，没有任何依赖。

### 值传递vs引用传递

值类型：理解为存储的数值本身

将数据传递给其他的变量，传递的是数据的副本（备份）

int\float\string\bool\array

引用类型：理解为存储的数据的内存地址

slice\map

### 切片slice

* 每一个切片引用了一个底层数组；
* 切片本身不存储任何数据，都是这个底层数组存储，所以修改切片也就是修改这个数组中的数据；
* 当向切片中添加数据时，如果没有超过容量，直接添加，如果超过容量，自动扩容（成倍增长）；
* 切片一旦扩容，就是重新指向一个新的底层数据

### 深拷贝vs浅拷贝

深拷贝：拷贝的是数据本身（切片使用copy函数）

值类型的数据，默认都是深拷贝：array\int\float\string\bool\struct

浅拷贝：拷贝的是数据地址

导致多个变量指向同一内存，引用类型的数据，默认都是浅拷贝：slice\map

因为切片是引用类型的数据，直接拷贝的是地址。

### 参数传递

值传递：传递的是数据的副本。修改数据，对于原始的数据并没有影响，值类型的数据，默认都是值传递：基础类型、array、struct

引用传递：传递的是数据的地址。导致多个变量指向同一块内存。引用类型的数据，默认都是引用传递：slice、map、chan

### 闭包

闭包：一个外层函数，有内层函数，会操作外层函数的局部变量（外层函数中的参数，或者外层函数中直接定义的变量），并且该外层函数的返回值就是这个内层函数。这个内层函数和外层函数的返回值，统称闭包结构。

此时局部变量的生命周期会发生改变，闭包结构中的外层函数的局部变量并不会随着外层函数的结束而销毁，因为内层函数还要继续使用。

```go
func TestBibao(t *testing.T){
   fun:=increment()
   fmt.Printf("%T\n",fun)
   v1:=fun()
   fmt.Println(v1)
   v2:=fun()
   fmt.Println(v2 )
}

func increment() func() int{
   i:=0
   fun:=func() int{
      i++
      return i
   }
   return fun
}

//output:
func() int
1
2
```

i是函数中局部变量，正常来说应该随着函数的结束而销毁，但是如果函数的返回值是一个内层函数，而且内层函数中设计了变量i，那么i就不能随着increment而销毁；因为当把内层函数作为返回值给调用处时，内层函数一旦被调用，还是需要使用到i。

### 数组指针vs指针数组

数组指针：首先是一个指针，一个数组的地址 *[4]Type

```go
func TestPoint(t *testing.T){
	arr1:=[4]int{1,2,3,4}
	fmt.Println(arr1)
	var p1 *[4]int
	p1=&arr1
	fmt.Println(p1)
	fmt.Printf("%T\n",p1)
	//数组arr1的地址
	fmt.Printf("%p\n",p1)
	fmt.Printf("%p\n",&arr1)
	//p1自己的地址
	fmt.Printf("%p\n",&p1)
	//根据数组指针，操作数组
	(*p1)[0]=100
	fmt.Println(arr1)
	//简化写法
	p1[0]=200
	fmt.Println(arr1)
}
//output:
[1 2 3 4]
&[1 2 3 4]
*[4]int
0xc000018260
0xc000018260
0xc00000e038
[100 2 3 4]
[200 2 3 4]
```

指针数组：首先是一个数组，存储的数据类型是指针 [4]*Type

```go
func TestPointArray(t *testing.T){
	a:=1
	b:=1
	c:=3
	d:=4
	arr1:=[]int{a,b,c,d}
	arr2:=[]*int{&a,&b,&c,&d}
	fmt.Println(arr1)
	fmt.Println(arr2)
	for _,val:=range arr2{
		fmt.Printf("%d\t",*val)
	}
	fmt.Println()
	c=100
	fmt.Println(arr1)
	fmt.Println(arr2)
	for _,val:=range arr2{
		//arr【2】变成100
		fmt.Printf("%d\t",*val)
	}
	fmt.Println()
	arr1[1]=666
	fmt.Println(b)
	*arr2[1]=666
	fmt.Println(b)
}
//output:
[1 1 3 4]
[0xc0000a61d0 0xc0000a61d8 0xc0000a61e0 0xc0000a61e8]
1	1	3	4	
[1 1 3 4]
[0xc0000a61d0 0xc0000a61d8 0xc0000a61e0 0xc0000a61e8]
1	1	100	4	
1
666
```

### 函数指针vs指针函数

函数指针：一个指针，指向了一个函数

因为在go语言中，function默认为一个指针，所以不必过多纠结，只是一个概念

指针函数：一个函数，返回值是一个指针

指针函数：

### 结构体嵌套（值传递）

```go
type book struct{
	bookName string
}

type student struct{
	name string
	b book
}

func TestStruct(t *testing.T){
	var s student
	var b book
	s.name="小米"
	s.b=b
	//值传递
	b.bookName="haha_book"
	fmt.Println(s)
	fmt.Println(b)
}
//output:
{小米 {}}
{haha_book}
```

注意区分出与Java的区别：若为Java，此时s中的bookname为haha_book，但Go的结构体嵌套为值传递，所以并未修改到s中的属性。

若想修改，可将student中的book改变为指针类型，具体如下：

```go
type book struct{
	bookName string
}

type student struct{
	name string
	b *book
}

func TestStruct(t *testing.T){
	var s student
	var b book
	s.name="小米"
	s.b=&b
	//值传递
	b.bookName="haha_book"
	fmt.Println(s)
	fmt.Println(s.b)
	fmt.Printf("%p\n",&b)
	fmt.Println(b)
}
//output:
{小米 0xc000052580}
&{haha_book}
0xc000052580
{haha_book}
```

### 继承

Go语言的结构体嵌套：

1.模拟继承性：is - a

```go
type A struct{
    field
}
type B struct{
    A //匿名字段
}
```

2.模拟聚合关系：has - a

```go
type C struct{
    field
}
type D struct{
    c C //聚合关系	
}
```

继承示例：

```go
type Person struct {
	name string
	age int
}

type Student struct {
	Person //结构体嵌套，模拟继承性
	school string
}

func (p Person) eat(){
	fmt.Println("Person eat")
}

func (s Student) eat(){
	fmt.Println("Student eat")
}

func TestMethod(t *testing.T){
	var p Person
	p.name="Amy"
	p.age=23
	p.eat()
	var s Student
	s.Person=p
	fmt.Println(s.name)
	s.eat()
}
//output:
Person eat
Amy
Student eat
```

### Panic&Recover

Go中引入两个内置函数panic和recover来触发和终止异常处理流程，同时引入关键字defer来延迟执行defer后面的函数。

当程序运行时，如果遇到引用空指针、下标越界或显示调用panic函数等情况，则先触发panic函数的执行，然后调用延迟函数，调用者继续传递panic，因此该过程一直在调用栈中进行：函数停止执行，调用延迟执行函数。如果一路在延迟函数中没有recover函数的调用，则会到达该协程的起点，该协程结束，然后终止其他所有协程，包括主协程。

panic：

1. 内建函数
2. 加入函数F中写入panic语句，会终于其后执行的代码，在panic所在函数F内如果存在要执行的defer函数列表，按照逆序执行；
3. 返回函数F的调用者G，在G中，调用函数F语句之后的代码不会执行，假如函数G中存在要执行的函数列表，逆序执行，defer类似于try-catch-finally中的finally
4. 直到goroutine整个退出，并报告错误；

recover：

1. 内建函数
2. 用来控制一个goroutine的panicking行为，捕获panic，从而影响应用的行为
3. 一般的调用建议

> 在defer函数中，通过recover来终止一个goroutine的panicking过程，从而恢复正常代码的执行；
>
> 可以获取通过panic传递的error

简而言之：go中可以抛出一个panic的异常，然后在defer中通过recover来捕获这个异常，然后正常处理。

### 包的使用

* 一个目录下的文件归属一个包，package的声明要一致；
* package声明的包和对应的目录名可以不一致，但习惯上还是写成一致的；
* 包可以嵌套；
* 同包下的函数不需要导入包，可以直接使用；
* main包，main()函数所在的包，其他的包不能使用；
* 导入包的时候，路径从src下开始写

### init()包初始化

init()、main()是go中的保留函数，init函数会在包导入时执行，例如如果是在main中导入包，包中存在init函数，那么init的代码会在main函数执行前执行。

init执行顺序：

* 对同一个go文件的init函数调用顺序：从上到下

* 对同一个package中的不同文件调用顺序：按文件名字符串从小到大

* 对不同的package

  如果不互相依赖，按照main中import的顺序；

  如果存在依赖，调用顺序为最后被依赖的最先被初始化，例如：导入顺序：main-A-B-C，则初始化顺序为C-B-A-main，依次执行对应的init方法，main包总是最后一个被初始化，因为它总是依赖别的包。

* 避免出现循环import，例如：A-B-C-A。
* 一个包被其他多个包import，但只能初始化一次。
* _操作，其实是引入该包，而不直接使用包里面的函数，仅仅是调用了该包里的init()

### 文件复制

* 方法一：io包下的Read和Write方法实现
* 方法二：io包下的Copy方法
* 方法三：ioutil包

注意：IO包中的元素都使用了copyBuffer方法；

#### 断点续传

```go
func TestSeek(t *testing.T) {
	srcFile := "pict1.jpg"
	file1, err := os.Open(srcFile)
	HandlerError(err)
	destFile := "pict2.jpg"
	file2, err := os.OpenFile(destFile, os.O_CREATE|os.O_WRONLY, os.ModePerm)
	tempFile := "pictTemp.txt"
	file3, err := os.OpenFile(tempFile, os.O_CREATE|os.O_RDWR, os.ModePerm)
	HandlerError(err)
	defer file1.Close()
	defer file2.Close()

	//1.先读取临时文件中的数据，再seek
	file3.Seek(0, io.SeekStart)
	bs := make([]byte, 100, 100)
	n1, err := file3.Read(bs)
	countStr := string(bs[:n1])
	//fmt.Println(countStr)
	count, err := strconv.ParseInt(countStr, 10, 64)
	//fmt.Println(count)

	//2.设置读写的位置
	file1.Seek(count, io.SeekStart)
	file2.Seek(count, io.SeekStart)
	data := make([]byte, 1024, 1024)
	n2 := -1            //读取的数据量
	n3 := -1            //写出的数据量
	total := int(count) //读取的总量

	//3.复制文件
	for {
		n2, err = file1.Read(data)
		if err == io.EOF || n2 == 0 {
			fmt.Println("文件复制完毕")
			file3.Close()
			os.Remove(tempFile)
			break
		}
		n3, err = file2.Write(data[:n2])
		total += n3
		//将复制的总量，存储到临时文件中
		file3.Seek(0, io.SeekStart)
		file3.WriteString(strconv.Itoa(total))

		fmt.Println(total)

		//if total>8000{
		//	panic("假装断电")
		//}

	}
}
```

### bufio

bufio：通过缓冲区，实现高效io读写；

即buffer缓存+IO（input、output）

将IO包下的Reader、Writer对象进行包装，带缓存的包装以提高读写的效率；

ReadBytes\()、ReadString()、ReadLine()

### 遍历文件夹

```go
func TestList(t *testing.T){
	 dirName:="/home/myshare"
	 listFiles(dirName,0)
}

func listFiles(dirName string, level int) {
	s:="|--"
	for i := 0; i < level; i++ {
		s ="|  "+s
	}
	fileInfos,err:=ioutil.ReadDir(dirName)
	if err!=nil{
		log.Fatal(err)
	}
	for _,fi:=range fileInfos{
		fileName:=dirName+"/"+fi.Name()
		fmt.Printf("%s%s\n",s,fileName)
		if fi.IsDir() {
			listFiles(fileName,level+1)
		}
	}
}
```

### 单向通道

单向通道一般存在于形参中，用来规范方法的行为。

```go
package ch12

import (
	"fmt"
	"testing"
)

func TestSingleChannel(t *testing.T) {
	ch1 := make(chan int)
	//data:=<-ch1
	go getData(ch1)
	ch1 <- 5

	ch2 := make(chan int)
	go singleSendData(ch2)
	data := <-ch2
	fmt.Println(data)
}

func getData(ch <-chan int) {
	data := <-ch
	fmt.Println(data)
}

func singleSendData(ch chan<- int) {
	ch<-200
}
```

### timer

```go
func TestTime(t *testing.T){
	fmt.Println(time.Now())
	timer1 :=time.NewTimer(3*time.Second)
	go func(){
		fmt.Println(1)
		data:=<-timer1.C
		fmt.Println(data)
		fmt.Println(2)
	}()
	time.Sleep(5*time.Second)
	flag:= timer1.Stop()
	if flag{
		fmt.Println("timer1停止了")
	}
}
//output:
2020-07-03 23:15:02.048146765 +0800 CST m=+0.000538866
1
2020-07-03 23:15:05.048376293 +0800 CST m=+3.000768594
2
```

* timer.After()：直接返回通道

```go
func TestTimerAfter(t *testing.T){
	timer1:=time.After(3*time.Second)
	fmt.Println(time.Now())
	data:=<-timer1
	fmt.Println(data)
}
//output:
2020-07-03 23:15:31.58398707 +0800 CST m=+0.000507979
2020-07-03 23:15:34.584050115 +0800 CST m=+3.000571034
源码：
func After(d Duration) <-chan Time {
	return NewTimer(d).C
}
```

### Select

分支语句：if、switch、select

select语句类型与switch语句区别不多。

但是**select语句会随机执行一个可运行的case**，如果没有case可以运行，要看是否有default，如果有就执行default，否则则进入阻塞，直到有case可以运行。

```go
func TestSelect(t *testing.T) {
	ch1 := make(chan int)
	ch2 := make(chan int)

	go func() {
		time.Sleep(2 * time.Second)
	}()
	select {
	case num1 := <-ch1:
		fmt.Println("num1:", num1)
	case num2, ok := <-ch2:
		if ok {
			fmt.Println("num2:", num2)
		} else {
			fmt.Println("ch2已关闭")
		}
	case <-time.After(1 * time.Second):
		fmt.Println("case3执行")
		//default:
		//	fmt.Println("default")
	}

}
//output:
case3执行
```

加上default：

```go
func TestSelect(t *testing.T) {
	ch1 := make(chan int)
	ch2 := make(chan int)

	go func() {
		time.Sleep(2 * time.Second)
	}()
	select {
	case num1 := <-ch1:
		fmt.Println("num1:", num1)
	case num2, ok := <-ch2:
		if ok {
			fmt.Println("num2:", num2)
		} else {
			fmt.Println("ch2已关闭")
		}
	case <-time.After(1 * time.Second):
		fmt.Println("case3执行")
	default:
		fmt.Println("default")
	}
}
//output:
default
```

