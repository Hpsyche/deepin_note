## Golang CSP

与主流语言通过共享内存来进行并发控制方式不同，Go语言采用了CSP模型。这是一种用于描述两个独立的并发实体通过共享的通讯Channel进行通信的并发模型。

Golang借用了CSP模型的一些概念，并没有完成使用所有理论，仅仅借用了process和channel这两个概念，其分别对应与golang中的goroutine和channel，goroutine是实际并发执行的实体，每个实体之间是通过channel通讯来实现数据共享。

### Channel

Goroutine和Channel是Go并发编程中的两大基石。Goroutine用于执行并发任务，Channel用于goroutine之间的同步、通信。

还是那句话：不要通过共享内存来通信，而要通过通信来实现内存共享。

### Goroutine

Goroutine是实际并发执行的实体，它底层是使用协程（coroutine）实现并发，coroutine是一种运行在用户态的线程，类似于greenthread，go底层选择使用coroutine的出发点是因为，它具有如下特点：

* 用户空间：避免了内核态和用户态的切换成本
* 可以由语言和框架层进行调度
* 更小的栈空间允许创建大量的实例

可以看到第二条，用户空间线程的调度不由操作系统完成，像jdk1.3中的greenthread是由JVM统一调度的（后Java改为内核线程），而goroutine是在golang层面提供了调度器，并且对网络IO库进行了封装，屏蔽了复杂的细节，对外提供同意的语法关键字支持，简化了并发程序编写的成本。

### Goroutine调度器

Go并发调度：G-P-M模型。

在操作系统提供的内核线程上，Go搭建了一个特有的两级线程模型，goroutine机制实现了M：N的线程模型，goroutine机制是协程的一种实现，golang内置的调度器，可以让多核CPU中每一个CPU执行一个线程。

![](/media/hpsyche/_dde_data/note/go/千峰/pict/3-1.png)



