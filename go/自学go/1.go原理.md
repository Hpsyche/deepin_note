Go 编程语言是一个开源项目，它使程序员更具生产力。

Go 语言具有很强的表达能力，它简洁、清晰而高效。得益于其并发机制， 用它编写的程序能够非常有效地利用多核与联网的计算机，其新颖的类型系统则使程序结构变得灵活而模块化。 **Go 代码编译成机器码不仅非常迅速，还具有方便的垃圾收集机制和强大的运行时反射机制。 它是一个快速的、静态类型的编译型语言，感觉却像动态类型的解释型语言。**

## 编译型语言

对于C、C++和Go，它们经过一次编译之后，可以由操作系统直接执行，所以它们是编译型语言。而Java不一样，它首先由编译器编译成.class（字节码）文件，然后在通过JVM从.class文件中读一行解释执行一行，所以它是解释型的语言。

编译型语言，执行速度快、效率高；依靠编译器、跨平台性差。

解释型语言，执行速度慢、效率低；依靠解释器、跨平台性好。

## Go的源码文件

Go 的源码文件分类：

![](/media/hpsyche/_dde_data/note/go/自学go/pict/1-1.png)

如上图，分为三类：

### 命令源码文件

声明自己属于 main 代码包、包含无参数声明和结果声明的 main 函数。

命令源码文件被安装以后，GOPATH 如果只有一个工作区，那么相应的可执行文件会被存放当前工作区的 bin 文件夹下；如果有多个工作区，就会安装到 GOBIN 指向的目录下。

命令源码文件是 Go 程序的入口。

**同一个代码包中最好也不要放多个命令源码文件。多个命令源码文件虽然可以分开单独 go run 运行起来，但是无法通过 go build 和 go install。**

如我们在目录在添加helloworld.go和helloworld2.go，都声明main函数，结果如下：

![](/media/hpsyche/_dde_data/note/go/自学go/pict/1-2.png)

这也就证明了多个命令源码文件虽然可以分开单独 go run 运行起来，但是无法通过 go build 和 go install。

同理，如果命令源码文件和库源码文件也会出现这样的问题，库源码文件不能通过 go build 和 go install 这种常规的方法编译和安装。具体例子和上述类似，这里就不再贴代码了。

所以命令源码文件应该是被单独放在一个代码包中。

### 库源码文件

库源码文件就是不具备命令源码文件上述两个特征的源码文件。**存在于某个代码包中的普通的源码文件。**

库源码文件被安装后，相应的归档文件（.a 文件）会被存放到当前工作区的 pkg 的平台相关目录下。

即go install库源码文件会产生.a文件于pkg中。

### 测试源码文件

名称以 _test.go 为后缀的代码文件，并且必须包含 Test 或者 Benchmark 名称前缀的函数。

名称以 Test 为名称前缀的函数，只能接受 *testing.T 的参数，这种测试函数是功能测试函数。

名称以 Benchmark 为名称前缀的函数，只能接受 *testing.B 的参数，这种测试函数是性能测试函数。

命令源码文件是可以单独运行的。可以使用 go run 命令直接运行，也可以通过 go build 或 go install 命令得到相应的可执行文件。所以命令源码文件是可以在机器的任何目录下运行的。

## Go命令

在探索 Go 的编译命令之前，需要说明的一点是：

Go 程序是通过 package 来组织的。

package <pkgName>（假设我们的例子中是 package main）这一行告诉我们当前文件属于哪个包，而包名 main 则告诉我们它是一个可独立运行的包，它在编译后会产生可执行文件。除了 main 包之外，其它的包最后都会生成 *.a 文件（也就是包文件）并放置在 $GOPATH/pkg/$GOOS_$GOARCH中（以 Linux为例就是
 $GOPATH/pkg/linux_amd64 ）。

Go 使用 package（和 Python 的模块类似）来组织代码。main.main() 函数(这个函数位于主包）是每一个独立的可运行程序的入口点。

> 每一个可独立运行的 Go 程序，必定包含一个 package main，在这个 main 包中必定包含一个入口函数 main，而这个函数既没有参数，也没有返回值。

```go
build       compile packages and dependencies
clean       remove object files
doc         show documentation for package or symbol
env         print Go environment information
bug         start a bug report
fix         run go tool fix on packages
fmt         run gofmt on package sources
generate    generate Go files by processing source
get         download and install packages and dependencies
install     compile and install packages and dependencies
list        list packages
run         compile and run Go program
test        test packages
tool        run specified go tool
version     print Go version
vet         run go tool vet on packages
```

## Go编译

其中和编译相关的有 build、get、install、run 这4个。接下来就依次看看这四个的作用。

在详细分析这4个命令之前，先罗列一下通用的命令标记，以下这些命令都可适用的：

| 名称  | 说明                                                         |
| ----- | ------------------------------------------------------------ |
| -a    | 用于强制重新编译所有涉及的 Go 语言代码包（包括 Go 语言标准库中的代码包），即使它们已经是最新的了。该标记可以让我们有机会通过改动底层的代码包做一些实验。 |
| -n    | 使命令仅打印其执行过程中用到的所有命令，而不去真正执行它们。如果不只想查看或者验证命令的执行过程，而不想改变任何东西，使用它正好合适。 |
| -race | 用于检测并报告指定 Go 语言程序中存在的数据竞争问题。当用 Go 语言编写并发程序的时候，这是很重要的检测手段之一。 |
| -v    | 用于打印命令执行过程中涉及的代码包。这一定包括我们指定的目标代码包，并且有时还会包括该代码包直接或间接依赖的那些代码包。这会让你知道哪些代码包被执行过了。 |
| -work | 用于打印命令执行时生成和使用的临时工作目录的名字，且命令执行完成后不删除它。这个目录下的文件可能会对你有用，也可以从侧面了解命令的执行过程。如果不添加此标记，那么临时工作目录会在命令执行完毕前删除。 |
| -x    | 使命令打印其执行过程中用到的所有命令，并同时执行它们。       |

### Go run

专门用来运行命令源码文件的命令，**注意，这个命令不是用来运行所有 Go 的源码文件的！**

go run 命令只能接受一个命令源码文件以及若干个库源码文件（必须同属于 main 包）作为文件参数，且**不能接受测试源码文件**。它在执行时会检查源码文件的类型。如果参数中有多个或者没有命令源码文件，那么 go run 命令就只会打印错误提示信息并退出，而不会继续执行。

通过-n具体分析go run干了什么：

```go
hpsyche@hpsyche-PC:~/go/src/learn_go/ch1$ go run -n helloworld.go 

......
mkdir -p $WORK/b001/exe/
cd .
/usr/local/go/pkg/tool/linux_amd64/link -o $WORK/b001/exe/helloworld -importcfg $WORK/b001/importcfg.link -s -w -buildmode=exe -buildid=rwezckM-wd05gQQp3YVc/JH6po3MP3eHaVBmkMc1i/5LAyQkZaarSYMmG5g5aR/rwezckM-wd05gQQp3YVc -extld=gcc /home/hpsyche/.cache/go-build/f0/f033423bd83ab03a6a96444af99f7d0066fa57275f960a9183f8dd82b851cab9-d
$WORK/b001/exe/helloworld
```

这里可以看到创建了两个临时文件夹 _obj 和 exe，先执行了 compile 命令，然后 link，生成了归档文件.a 和 最终可执行文件，最终的可执行文件放在 exe 文件夹里面。命令的最后一步就是执行了可执行文件。

总结go run执行过程如下：

![](/media/hpsyche/_dde_data/note/go/自学go/pict/1-3.png)

举个例子，生成的临时文件可以用`go run -work`看到，如当前生成的临时文件夹是如下的路径：/tmp/go-build726786221

树形显示目录结构如下：

![](/media/hpsyche/_dde_data/note/go/自学go/pict/1-4.png)

可以看到，最终`go run`命令是生成了2个文件，一个是归档文件，一个是可执行文件。

go run 命令在第二次执行的时候，如果发现导入的代码包没有发生变化，那么 go run 不会再次编译这个导入的代码包。直接静态链接进来。

可以通过go run -a强制编译所有的代码，即使归档文件.a存在，也会重新编译。

如果嫌弃编译速度慢，可以加上`-p n`，这个是并行编译，n是并行的数量。n一般为逻辑 CPU 的个数。

### Go build

当代码包中有且仅有一个命令源码文件的时候，在文件夹所在目录中执行 go build 命令，会在该目录下生成一个与目录同名的可执行文件。

于是在当前目录直接生成了以当前文件夹为名的可执行文件。

go build 用于编译我们指定的源码文件或代码包以及它们的依赖包。，但是**注意如果用来编译非命令源码文件，即库源码文件，go build 执行完是不会产生任何结果的。这种情况下，go build 命令只是检查库源码文件的有效性，只会做检查性的编译，而不会输出任何结果文件。**

通过`go run work`可以看到，执行过程和 go run 大体相同，唯一不同的就是在最后一步，go run 是执行了可执行文件，但是 go build 命令是把可执行文件移动到了当前目录的文件夹中。

总结一下如下图：

![](/media/hpsyche/_dde_data/note/go/自学go/pict/1-5.png)

### Go install

go install 命令是用来**编译并安装代码包或者源码文件**的。

go install 用于编译并安装指定的代码包及它们的依赖包。当指定的代码包的依赖包还没有被编译和安装时，该命令会先去处理依赖包。与 go build 命令一样，传给 go install 命令的代码包参数应该以导入路径的形式提供。并且，go build 命令的绝大多数标记也都可以用于go install 命令。

**实际上，go install 命令只比 go build 命令多做了一件事，即：安装编译后的结果文件到指定目录。**

* 安装代码包会在当前工作区的 pkg 的平台相关目录下生成归档文件（即 .a 文件）。
* 安装命令源码文件会在当前工作区的 bin 目录（如果 GOPATH 下有多个工作区，就会放在 GOBIN 目录下）生成可执行文件。

总结一下如下图：

![](/media/hpsyche/_dde_data/note/go/自学go/pict/1-6.png)

### Go get

go get 命令用于从远程代码仓库（比如 Github ）上下载并安装代码包。**注意，go get 命令会把当前的代码包下载到 $GOPATH 中的第一个工作区的 src 目录中，并安装。**

> 使用 go get 下载第三方包的时候，依旧会下载到 $GOPATH 的第一个工作空间，而非 vendor 目录。当前工作链中并没有真正意义上的包依赖管理，不过好在有不少第三方工具可选。

如果在 go get 下载过程中加入`-d` 标记，那么下载操作只会执行下载动作，而不执行安装动作。比如有些非常特殊的代码包在安装过程中需要有特殊的处理，所以我们需要先下载下来，所以就会用到`-d` 标记。

还有一个很有用的标记是`-u`标记，加上它可以利用网络来更新已有的代码包及其依赖包。如果已经下载过一个代码包，但是这个代码包又有更新了，那么这时候可以直接用`-u`标记来更新本地的对应的代码包。如果不加这个`-u`标记，执行 go get 一个已有的代码包，会发现命令什么都不执行。只有加了`-u`标记，命令会去执行 git pull 命令拉取最新的代码包的最新版本，下载并安装。

命令 go get 还有一个很值得称道的功能——智能下载。在使用它检出或更新代码包之后，它会寻找与本地已安装 Go 语言的版本号相对应的标签（tag）或分支（branch）。比如，本机安装 Go 语言的版本是1.x，那么 go get 命令会在该代码包的远程仓库中寻找名为 “go1” 的标签或者分支。如果找到指定的标签或者分支，则将本地代码包的版本切换到此标签或者分支。如果没有找到指定的标签或者分支，则将本地代码包的版本切换到主干的最新版本。

go get 命令究竟做了些什么呢？我们还是来打印一下每一步的执行过程。

```go
cd .
git clone https://github.com/go-errors/errors /Users/YDZ/Ele_Project/clairstormeye/src/github.com/go-errors/errors
cd /Users/YDZ/Ele_Project/clairstormeye/src/github.com/go-errors/errors
git submodule update --init --recursive
cd /Users/YDZ/Ele_Project/clairstormeye/src/github.com/go-errors/errors
git show-ref
cd /Users/YDZ/Ele_Project/clairstormeye/src/github.com/go-errors/errors
git submodule update --init --recursive
WORK=/var/folders/66/dcf61ty92rgd_xftrsxgx5yr0000gn/T/go-build124856678
mkdir -p $WORK/github.com/go-errors/errors/_obj/
mkdir -p $WORK/github.com/go-errors/
cd /Users/YDZ/Ele_Project/clairstormeye/src/github.com/go-errors/errors
/usr/local/Cellar/go/1.8.3/libexec/pkg/tool/darwin_amd64/compile -o $WORK/github.com/go-errors/errors.a -trimpath $WORK -p github.com/go-errors/errors -complete -buildid bb3526a8c1c21853f852838637d531b9fcd57d30 -D _/Users/YDZ/Ele_Project/clairstormeye/src/github.com/go-errors/errors -I $WORK -pack ./error.go ./parse_panic.go ./stackframe.go
mkdir -p /Users/YDZ/Ele_Project/clairstormeye/pkg/darwin_amd64/github.com/go-errors/
mv $WORK/github.com/go-errors/errors.a /Users/YDZ/Ele_Project/clairstormeye/pkg/darwin_amd64/github.com/go-errors/errors.a
```

这里可以很明显的看到，执**行完 go get 命令以后，会调用 git clone 方法下载源码，并编译，最终会把库源码文件编译成归档文件安装到 pkg 对应的相关平台目录下。**

![](/media/hpsyche/_dde_data/note/go/自学go/pict/1-7.png)

## 其他常见命令

### Go clean

go clean 命令是用来移除当前源码包里面编译生成的文件，这些文件包括

- _obj/ 旧的object目录，由Makefiles遗留
- _test/ 旧的test目录，由Makefiles遗留
- _testmain.go 旧的gotest文件，由Makefiles遗留
- test.out 旧的test记录，由Makefiles遗留
- build.out 旧的test记录，由Makefiles遗留
- *.[568ao] object文件，由Makefiles遗留
- DIR(.exe) 由 go build 产生
- DIR.test(.exe) 由 go test -c 产生
- MAINFILE(.exe) 由 go build MAINFILE.go产生

### Go test

go test 命令，会自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件。默认的情况下，不需要任何的参数，它会自动把你源码包下面所有test文件测试完毕，当然你也可以带上参数，详情请参考go help testflag。

### Go doc

go doc 命令其实就是一个很强大的文档工具。

如何查看相应package的文档呢？ 例如builtin包，那么执行go doc builtin；如果是http包，那么执行go doc net/http；查看某一个包里面的函数，那么执行go doc fmt Printf；也可以查看相应的代码，执行go doc -src fmt Printf；

```
# 查看net/http包
localhost:hello ruby$ go doc net/http
# 查看time包
localhost:hello ruby$ go doc time
# 查看某个包里的指定函数
localhost:hello ruby$ go doc fmt Printf
```

通过命令在命令行执行 go doc -http=:端口号，比如godoc -http=:8080。然后在浏览器中打开127.0.0.1:8080，你将会看到一个golang.org的本地copy版本，通过它你可以查询pkg文档等其它内容。如果你设置了GOPATH，在pkg分类下，不但会列出标准包的文档，还会列出你本地GOPATH中所有项目的相关文档，这对于经常被限制访问的用户来说是一个不错的选择。

```
localhost:hello ruby$ godoc -http=:9527
```

## 静态链接or动态链接

Go 在最初刚刚发布的时候，静态链接被当做优点宣传，只须编译后的一个可执行文件，无须附加任何东西就能部署。将运行时、依赖库直接打包到可执行文件内部，简化了部署和发布的操作，无须事先安装运行环境和下载诸多第三方库。不过最新版本却又加入了动态链接的内容了。

普通的 go build 、go install 用的都是静态链接。可以验证一下：

![](/media/hpsyche/_dde_data/note/go/自学go/pict/1-8.png)

可以看到 fmt.Println 的地址是确定的，所以可以确定是静态链接的。

目前最新版的 Go 是如何支持动态链接的呢？

在 go build 、go install 的时候加上 -buildmode 参数。

这些是以下 buildmode 的选项：

* archive: 将非 main 包构建为 .a 文件 . main 包将被忽略。

* c-archive: 将 main 软件包及其导入的所有软件包构建到 C 归档文件中

* c-shared: 将列出的主要软件包，以及它们导入的所有软件包构建到C 动态库中。

* shared: 将所有列出的非 main 软件包合并到一个动态库中。

* exe: 构建列出的 main 包及其导入到可执行文件中的一切。 将忽略未命名为 main 的包。

  默认情况下，列出的 main 软件包内置到可执行文件中，列出的非main 软件包内置到 .a 文件中。