我们知道，linux常用io复用函数有select\poll\epoll，那他们具体的区别是什么呢？

## Select

![](/media/hpsyche/_dde_data/note/计算机基础/pict/6-1.png)

对于select，系统会创建一个位图bitmap（默认1024），用来存储文件描述符fd，如果我们监听了以下五个文件，描述符分别为：1\2\5\7\9，那么bitmap如下：

0110010101000.....

在select中，需要将bigmap从用户态拷贝到内核态进行轮循判断（为什么不在用户态，因为用户态也需要通过内核态才能进行判断，直接搬到内核态，避免了在用户态和内核态的上下文切换。），如果判断到有数据了：1.对收到数据的fd进行置位，2.select函数返回

同时，我们看到在上面while(1)循环中，FD_ZERO(&rset)和for循环的操作每次都要进行，即bigmap无法重用，你可能会有疑问，把bitmap中的某个位置置1后，线程处理后把那个位置重新置为0，不就可以了么？

> 注意bitmap这个结构只有在内核区才能更改其中的位置，而在用户区的只是提供了ZERO和CLS操作，而且ZERO操作时直接用memset做的清零操作。事实上整个操作一般都是封装起来的，所以ZERO操作就会很重要。

在select函数中，int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval *timeout)，五个参数分别指的是：

* maxfdp是集合中所有文件描述符的范围，即所有文件描述符的最大值加1，不能错！在Windows中这个参数的值无所谓，可以设置不正确。 
* fd_set *readfds是指向fd_set结构的指针，这个集合中应该包括文件描述符，我们是要监视这些文件描述符的读变化的，即我们关心是否可以从这些文件中读取数据了，如果这个集合中有一个文件可读，select就会返回一个大于0的值，表示有文件可读，如果没有可读的文件，则根据timeout参数再判断是否超时，若超出timeout的时间，select返回0，若发生错误返回负值。可以传入NULL值，表示不关心任何文件的读变化。 
* fd_set *writefds是指向fd_set结构的指针，这个集合中应该包括文件描述符，我们是要监视这些文件描述符的写变化的，即我们关心是否可以向这些文件中写入数据了，如果这个集合中有一个文件可写，select就会返回一个大于0的值，表示有文件可写，如果没有可写的文件，则根据timeout参数再判断是否超时，若超出timeout的时间，select返回0，若发生错误返回负值。可以传入NULL值，表示不关心任何文件的写变化。 
* fd_set *errorfds同上面两个参数的意图，用来监视文件错误异常。 
* struct timeval* timeout是select的超时时间，这个参数至关重要，它可以使select处于三种状态：
  * 第一，若将NULL以形参传入，即不传入时间结构，就是将select置于阻塞状态，一定等到监视文件描述符集合中某个文件描述符发生变化为止；
  * 第二，若将时间值设为0秒0毫秒，就变成一个纯粹的非阻塞函数，不管文件描述符是否有变化，都立刻返回继续执行，文件无变化返回0，有变化返回一个正值；
  * 第三，timeout的值大于0，这就是等待的超时时间，即 select在timeout时间内阻塞，超时时间之内有事件到来就返回了，否则在超时后不管怎样一定返回，返回值同上述。

注意：select成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0，，具有超时时间

以上，我们总结select的缺点有：

* fd_size有限制，默认1024
* fdset不可重用，一次循环结束后需要重新创建
* 用户态和内核态拷贝产生开销
* o(n)时间复杂度的轮询

## poll

![](/media/hpsyche/_dde_data/note/计算机基础/pict/6-2.png)

poll是基于结构体存储来fd，成员变量如下：

```c
struct pollfd{
    int fd;//每一个 pollfd 结构体指定了一个被监视的文件描述符，可以传递多个结构体，指示 poll() 监视多个文件描述符。 
    short events;//表示要告诉操作系统需要监测fd的事件（输入、输出、错误），每一个事件有多个取值 
	short revents//revents 域是文件描述符的操作结果事件，内核在调用返回时设置这个域。events 域中请求的任何事件都可能在 revents 域中返回。 
}
```

poll函数如下int poll(struct pollfd fd[], nfds_t nfds, int timeout)，参数分别指的是：

* 第一个参数:一个结构数组,struct pollfd
* 第二个参数nfds：要监视的描述符的数目。
* 最后一个参数timeout：是一个用毫秒表示的时间，是指定poll在返回前没有接收事件时应该等待的时间。如果，它的值为-1，poll就永远都不会超时。如果整数值为32个比特，那么最大的超时周期大约是30分钟。

poll解决了select的1,2两个缺点。

即：

* 没有1024的限制
* 可以通过结构体pollfd的revents来置位，不需要每次循环都创建

但其外两个缺点poll仍未解决。

* 其还需将用户态的结构体拷贝至内核态
* o(n)的轮询开销

## epoll

首先说明一下，无论是select\poll还是epoll都是有事件的时候或者超时才返回。用epoll的目的一般是，其他代码不阻塞，仅仅在epoll调用处阻塞。

![](/media/hpsyche/_dde_data/note/计算机基础/pict/6-3.png)

对于epoll，有三个重要的函数：

* epoll_create 创建一个白板 存放fd_events

* epoll_ctl 用于向内核注册新的描述符或者是改变某个文件描述符的状态。**已注册的描述符在内核中会被维护在一棵红黑树上，同时会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。所以，当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后就来把socket插入到准备就绪链表里了。**

  * 为什么使用红黑树？

    epoll和poll的一个很大的区别在于，**poll每次调用时都会存在一个将pollfd结构体数组中的每个结构体元素从用户态向内核态中的一个链表节点拷贝的过程，而内核中的这个链表并不会一直保存，当poll运行一次就会重新执行一次上述的拷贝过程**，这说明一个问题：poll并不会在内核中为要监听的文件描述符长久的维护一个数据结构来存放他们，而**epoll内核中维护了一个内核事件表，它是将所有的文件描述符全部都存放在内核中，系统去检测有事件发生的时候触发回调**，当你要添加新的文件描述符的时候也是调用epoll_ctl函数使用EPOLL_CTL_ADD宏来插入，epoll_wait也不是每次调用时都会重新拷贝一遍所有的文件描述符到内核态。

    **当我现在要在内核中长久的维护一个数据结构来存放文件描述符，并且时常会有插入，查找和删除的操作发生，这对内核的效率会产生不小的影响，因此需要一种插入，查找和删除效率都不错的数据结构来存放这些文件描述符，那么红黑树当然是不二的人选。**

* **epoll_wait 通过回调函数内核会将 I/O 准备好的描述符加入到一个就绪句柄链表中管理**，进程调用 epoll_wait() 便可以得到事件完成的描述符。

对于epoll，解决了如下的缺点，即:

* 没有1024的限制
* 循环时无需置位等操作，由epoll_ctl维护的红黑树控制。
* epoll是内核空间用一个 红黑树维护所有的fd，只把就绪的fd用链表复制到用户空间，不再需要拷贝
* 就绪链表的遍历可以看做是o(1)的

### epoll的两种触发方式

epoll监控多个文件描述符的I/O事件。epoll支持边缘触发(edge trigger，ET)或水平触发（level trigger，LT)，通t过epoll_wait等待I/O事件，如果当前没有可用的事件则阻塞调用线程。

> select和poll只支持LT工作模式，epoll的默认的工作模式是LT模式。

区别是，LT模式下，只要一个句柄上的事件一次没有处理完，会在以后调用epoll_wait时次次返回这个句柄，而ET模式仅在第一次返回。

```tex
LT:水平触发
当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。

ET:边缘触发
和 LT 模式不同的是，通知之后进程必须立即处理事件。
下次再调用 epoll_wait() 时不会再得到事件到达的通知。很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。
```

LT, ET这件事怎么做到的呢？

当一个socket句柄上有事件时，内核会把该句柄插入上面所说的准备就绪list链表，这时我们调用epoll_wait，会把准备就绪的socket拷贝到用户态内存，然后：清空准备就绪list链表，最后，epoll_wait干了件事，就是**请空前检查这些socket，如果不是ET模式（就是LT模式的句柄了），并且这些socket上确实有未处理的事件时，又把该句柄放回到刚刚清空的准备就绪链表了。所以，非ET的句柄，只要它上面还有事件，epoll_wait每次都会返回这个句柄。（从上面这段，可以看出，LT还有个回放的过程，低效了）。**

举例1：

1. 读缓冲区刚开始是空的
2. 读缓冲区写入2KB数据
3. 水平触发和边缘触发模式此时都会发出可读信号
4. 收到信号通知后，读取了1KB的数据，读缓冲区还剩余1KB数据
5. 水平触发会再次进行通知，而边缘触发不会再进行通知

举例2：（以脉冲的高低电平为例）

- 水平触发：0为无数据，1为有数据。缓冲区有数据则一直为1，则一直触发。
- 边缘触发发：0为无数据，1为有数据，只要在0变到1的上升沿才触发。

> JDK并没有实现边缘触发，Netty重新实现了epoll机制，采用边缘触发方式；另外像Nginx也采用边缘触发。

JDK在Linux已经默认使用epoll方式，但是JDK的epoll采用的是水平触发，而Netty重新实现了epoll机制，采用边缘触发方式，netty epoll transport 暴露了更多的nio没有的配置参数，如 TCP_CORK, SO_REUSEADDR等等；另外像Nginx也采用边缘触发。

## 总结对比

### 1. 用户态将文件描述符传入内核的方式

- select：创建3个文件描述符集并拷贝到内核中，分别监听读、写、异常动作。这里受到单个进程可以打开的fd数量限制，默认是1024。
- poll：将传入的struct pollfd结构体数组拷贝到内核中进行监听。
- epoll：执行epoll_create会在内核的高速cache区中建立一颗红黑树以及就绪链表(该链表存储已经就绪的文件描述符)。接着用户执行的epoll_ctl函数添加文件描述符会在红黑树上增加相应的结点。

### 2. 内核态检测文件描述符读写状态的方式

- select：采用轮询方式，遍历所有fd，最后返回一个描述符读写操作是否就绪的mask掩码，根据这个掩码给fd_set赋值。
- poll：同样采用轮询方式，查询每个fd的状态，如果就绪则在等待队列中加入一项并继续遍历。
- epoll：采用回调机制。在执行epoll_ctl的add操作时，不仅将文件描述符放到红黑树上，而且也注册了回调函数，内核在检测到某文件描述符可读/可写时会调用回调函数，该回调函数将文件描述符放在就绪链表中。

### 3. 找到就绪的文件描述符并传递给用户态的方式

- select：将之前传入的fd_set拷贝传出到用户态并返回就绪的文件描述符总数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断。
- poll：将之前传入的fd数组拷贝传出用户态并返回就绪的文件描述符总数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断。
- epoll：epoll_wait只用观察就绪链表中有无数据即可，最后将链表的数据返回给数组并返回就绪的数量。**内核将就绪的文件描述符放在传入的数组中，所以只用遍历依次处理即可。（select、poll还需要再遍历一次）**

## 4. 重复监听的处理方式

- select：将新的监听文件描述符集合拷贝传入内核中，继续以上步骤。
- poll：将新的struct pollfd结构体数组拷贝传入内核中，继续以上步骤。
- epoll：无需重新构建红黑树，直接沿用已存在的即可。

## epoll更高效的原因

1. select和poll的动作基本一致，只是poll采用链表来进行文件描述符的存储，而select采用fd标注位来存放，所以select会受到最大连接数的限制，而poll不会。
2. select、poll、epoll虽然都会返回就绪的文件描述符数量。**但是select和poll并不会明确指出是哪些文件描述符就绪，而epoll会。造成的区别就是，系统调用返回后，调用select和poll的程序需要遍历监听的整个文件描述符找到是谁处于就绪，而epoll则直接处理即可。**
3. select、poll都需要将有关文件描述符的数据结构拷贝进内核，最后再拷贝出来。而epoll创建的有关文件描述符的数据结构本身就存于内核态中，需要在返回时将文件描述符数组拷贝回用户态即可。
4. select、poll采用轮询的方式来检查文件描述符是否处于就绪态，而epoll采用回调机制。造成的结果就是，随着fd的增加，select和poll的效率会线性降低，而epoll不会受到太大影响，除非活跃的socket很多。
5. epoll的边缘触发模式效率高，系统不会充斥大量不关心的就绪文件描述符

> **虽然epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。**